[comment encoding = UTF-8 /]
[module EcoreMAVOToSMTLIBUtils_M2T('http://www.eclipse.org/emf/2002/Ecore', 'http://se.cs.toronto.edu/mmtf/MAVO')]

[query public getObjectsOfType(root : EObject, eclass : EClass) : Sequence(OclAny) =
	root.eAllContents()->select(eClass().name = eclass.name)
/]

[query public getObjectsOfKind(root : EObject, eclass : EClass) : Sequence(OclAny) =
	root.eAllContents()->select(eClass().name = eclass.name or eClass().eAllSuperTypes->exists(name = eclass.name))
/]

[query public getGraphFunction(eclass : EClass) : String =
	if eclass.eAnnotations->exists(source = 'gmf.node') then 'node' else if eclass.eAnnotations->exists(source = 'gmf.link') then 'edge' else null endif endif
/]

[query public getMAVOElements(root : EObject) : Sequence(MAVOElement) =
	root.eAllContents(MAVOElement)
/]

[query public getMAVONodes(root : EObject) : Sequence(MAVOElement) =
	root.getMAVOElements()->select(eClass().getGraphFunction() = 'node')
/]

[query public getMAVOEdges(root : EObject) : Sequence(MAVOElement) =
	root.getMAVOElements()->select(eClass().getGraphFunction() = 'edge')
/]

[query public asMAVOElements(objects : Sequence(OclAny)) : Sequence(MAVOElement) =
	objects->collect(oclAsType(MAVOElement))
/]

[query public getMetamodelMAVOClasses(mavoModel : MAVOModel) : Sequence(EClass) =
	mavoModel.eClass().ePackage.eAllContents(EClass)->select(
		not abstract and
		eAllSuperTypes->exists(super : EClass | super.name = 'MAVOElement') and
		eAnnotations->exists(source = 'gmf.node' or source = 'gmf.link')
	)
/]

[query public getUnmergeableIds(mavoModel : MAVOModel, mavoModelObj : MAVOElement) : Sequence(String) =
	invoke(
		'edu.toronto.cs.se.mmtf.mavo.library.MAVOUtils',
		'getUnmergeableIds(edu.toronto.cs.se.mmtf.mavo.MAVOModel, edu.toronto.cs.se.mmtf.mavo.MAVOElement)',
		Sequence{mavoModel, mavoModelObj}
	)
/]

[query public createIdsFromNames(mavoModel : MAVOModel) : OclAny =
	invoke(
		'edu.toronto.cs.se.mmtf.mavo.library.MAVOUtils',
		'createIdsFromNames(edu.toronto.cs.se.mmtf.mavo.MAVOModel)',
		Sequence{mavoModel}
	)
/]

[template public encodeModel(mavoModel : MAVOModel)]
;Concretizations
(define-sort Node () Int)
(define-sort Edge () Int)
	[for (eclass : EClass | mavoModel.getMetamodelMAVOClasses())]
(declare-sort [eclass.name/])
		[let function : String = eclass.getGraphFunction()]
(declare-fun [function/] ([function.toUpperFirst()/] [eclass.name/]) Bool)
		[/let]
	[/for]

;Model
	[for (mavoElement : MAVOElement | mavoModel.getMAVOElements())]
		[let function : String = mavoElement.eClass().getGraphFunction()]
(declare-const [mavoElement.formulaId/] [function.toUpperFirst()/])
(assert (= [mavoElement.formulaId/] [i/]))
		[/let]
	[/for]
(declare-fun src (Edge) Node)
(declare-fun tgt (Edge) Node)
	[for (mavoElement : MAVOElement | mavoModel.getMAVOEdges())]
		[let srcFeature : String = mavoElement.eClass()->union(mavoElement.eClass().eAllSuperTypes)->collect(eAnnotations)->any(source = 'gmf.link' and details->exists(key = 'source')).details->any(key = 'source').value]
		[let tgtFeature : String = mavoElement.eClass()->union(mavoElement.eClass().eAllSuperTypes)->collect(eAnnotations)->any(source = 'gmf.link' and details->exists(key = 'target')).details->any(key = 'target').value]
		[let srcMavoElement : MAVOElement = mavoElement.eGet(srcFeature).oclAsType(MAVOElement)]
		[let tgtMavoElement : MAVOElement = mavoElement.eGet(tgtFeature).oclAsType(MAVOElement)]
(assert (= (src [mavoElement.formulaId/]) [srcMavoElement.formulaId/]))
(assert (= (tgt [mavoElement.formulaId/]) [tgtMavoElement.formulaId/]))
(assert (forall ((c [mavoElement.eClass().name/])) (=>
	(edge [mavoElement.formulaId/] c)
	(exists ((c1 [srcMavoElement.eClass().name/]) (c2 [tgtMavoElement.eClass().name/])) (and
		(node (src [mavoElement.formulaId/]) c1)
		(node (tgt [mavoElement.formulaId/]) c2)
	))
)))
[comment TODO MMTF: check if src and tgt functions are really needed (for i* analysis maybe) /]
		[/let]
		[/let]
		[/let]
		[/let]
	[/for]
[/template]

[template public encodeMAVOConstraints(mavoModel : MAVOModel)]
;Model is Complete
	[for (eclass : EClass | mavoModel.getMetamodelMAVOClasses())]
(assert	(forall ((c [eclass.name/])) (or
		[for (mavoElement : MAVOElement | mavoModel.getObjectsOfType(eclass)->asMAVOElements())]
			[let function : String = eclass.getGraphFunction()]
	([function/] [mavoElement.formulaId/] c)
			[/let]
		[/for]
)))
	[/for]
	[for (mavoElement : MAVOElement | mavoModel.getMAVOElements())]
		[let function : String = mavoElement.eClass().getGraphFunction()]
		[let sort : String = mavoElement.eClass().name]
		[if (not mavoElement.may)]
;[mavoElement.formulaId/] Exists
(assert (exists ((c [sort/])) ([function/] [mavoElement.formulaId/] c)))
		[/if]
		[if (not mavoElement.set)]
;[mavoElement.formulaId/] is Unique
(assert	(forall ((c1 [sort/]) (c2 [sort/])) (=>
	(and ([function/] [mavoElement.formulaId/] c1) ([function/] [mavoElement.formulaId/] c2))
	(= c1 c2)
)))
		[/if]
		[let unmergeableIds : Sequence(String) = mavoModel.getUnmergeableIds(mavoElement)]
		[if (not unmergeableIds->isEmpty())]
;[mavoElement.formulaId/] is Distinct
(assert	(forall ((c [sort/])) (=>
	([function/] [mavoElement.formulaId/] c)
	(not (or
			[for (unmergeableId : String | unmergeableIds)]
		([function/] [unmergeableId/] c)
			[/for]
	))
)))
		[/if]
		[/let]
		[comment TODO add edge constraints (edge implies existence of nodes) /]
		[/let]
		[/let]
	[/for]
[/template]
