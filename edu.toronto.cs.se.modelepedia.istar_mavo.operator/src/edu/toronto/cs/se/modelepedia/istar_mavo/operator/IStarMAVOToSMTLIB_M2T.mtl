[comment encoding = UTF-8 /]
[module IStarMAVOToSMTLIB_M2T('http://se.cs.toronto.edu/mmtf/MAVO', 'http://se.cs.toronto.edu/modelepedia/IStar_MAVO')]

[template private intentionalElementName(ie : IntentionalElement)]
[ie.name.replaceAll(' ', '')/]
[/template]

[template private endReferenceName(end : EndReference)]
[end.src.name.replaceAll(' ', '')/]2[end.tgt.name.replaceAll(' ', '')/]
[/template]

[template private componentsReferenceName(component : ComponentsReference)]
[component.src.name.replaceAll(' ', '')/]2[component.tgt.name.replaceAll(' ', '')/]
[/template]

[comment l'ie contiene giÃ  tutto, basta usare il suo ocl type/nome upper e lower case -> farlo anche per le funzioni sottostanti /]
[template private encodeInitialAnalysis(ie : IntentionalElement, sort : String, fun : String, name : String)]
;[name/] initial analysis tag
(assert (forall ((c [sort/])) (=>
	([fun/] [name/] c)
[if (ie.fullySatisfied or ie.partiallySatisfied or ie.unknown or ie.conflict or ie.partiallyDenied or ie.fullyDenied)]
	(and
	[if (ie.fullySatisfied)]
		(fs c)
	[else]
		(not (fs c))
	[/if]
	[if (ie.partiallySatisfied)]
		(ps c)
	[else]
		(not (ps c))
	[/if]
	[if (ie.unknown)]
		(un c)
	[else]
		(not (un c))
	[/if]
	[if (ie.conflict)]
		(co c)
	[else]
		(not (co c))
	[/if]
	[if (ie.partiallyDenied)]
		(pd c)
	[else]
		(not (pd c))
	[/if]
	[if (ie.fullyDenied)]
		(fd c)
	[else]
		(not (fd c))
	[/if]
		(inited c)
	)
[else]
	(not (inited c))
[/if]
)))
[/template]

[template private encodeMetamodelType(sort : String, fun : String, name : String, const : String)]
;[name/] type
(assert (forall ((c [sort/])) (=>
	([fun/] [name/] c)
	(= (decompositionType c) [const/])
)))
[/template]

[template private encodeMetamodelConstraint(sort : String, fun : String, funOverload : String, name : String, funSrc : String, nameSrc : String, funTgt : String, nameTgt : String)]
;[name/] src and tgt
(assert (forall ((c [sort/])) (=>
	([fun/] [name/] c)
	(and ([funSrc/] [nameSrc/] ([fun/]Src c)) ([funTgt/] [nameTgt/] ([if (funOverload.oclIsUndefined())][fun/]Tgt[else](as [fun/]Tgt ([funOverload/]))[/if] c)))
)))
[/template]

[template private encodeMayConstraint(sort : String, fun : String, name : String)]
;[name/] Exists
(assert	(exists ((c [sort/])) ([fun/] [name/] c)))
[/template]

[template private encodeSetConstraint(sort : String, fun : String, name : String)]
;[name/] is Unique
(assert	(forall ((c1 [sort/]) (c2 [sort/])) (=>
	(and ([fun/] [name/] c1) ([fun/] [name/] c2))
	(= c1 c2)
)))
[/template]

[template private encodeVarConstraint(sort : String, fun : String, name1 : String, name2 : String)]
;[name1/] is Distinct from [name2/]
(assert	(forall ((c [sort/])) (=>
	([fun/] [name1/] c)
	(not ([fun/] [name2/] c))
)))
[/template]

[template private encodeConstants(istar : IStar)]
;Decomposition Types
(declare-const DECOMPOSITION_TASK Int)
(declare-const DECOMPOSITION_GOAL Int)
(declare-const DECOMPOSITION_SOFTGOAL Int)
(assert (= DECOMPOSITION_TASK 1))
(assert (= DECOMPOSITION_GOAL 2))
(assert (= DECOMPOSITION_SOFTGOAL 3))

;Contribution Types
(declare-const UNKNOWN Int)
(declare-const HELP Int)
(assert (= UNKNOWN 4))
(assert (= HELP 5))
[/template]

[template private encodeModel(istar : IStar)]

;Model
(declare-datatypes () ((Task
	[for (actor : Actor | istar.actors)]
		[for (task : IntentionalElement | actor.intentionalElements->select(oclIsTypeOf(Task)))]
	[intentionalElementName(task)/]
		[/for]
	[/for]
)))
(declare-datatypes () ((Goal
	[for (actor : Actor | istar.actors)]
		[for (goal : IntentionalElement | actor.intentionalElements->select(oclIsTypeOf(Goal)))]
	[intentionalElementName(goal)/]
		[/for]
	[/for]
)))
(declare-datatypes () ((SoftGoal
	[for (actor : Actor | istar.actors)]
		[for (softgoal : IntentionalElement | actor.intentionalElements->select(oclIsTypeOf(SoftGoal)))]
	[intentionalElementName(softgoal)/]
		[/for]
	[/for]
)))
(declare-datatypes () ((MeansEnd
	[for (actor : Actor | istar.actors)]
		[for (task : IntentionalElement | actor.intentionalElements->select(oclIsTypeOf(Task)))]
			[for (end : EndReference | task.oclAsType(Task).end)]
	[endReferenceName(end)/]
			[/for]
		[/for]
	[/for]
)))
(declare-datatypes () ((Decomposition
	[for (actor : Actor | istar.actors)]
		[for (task : IntentionalElement | actor.intentionalElements->select(oclIsTypeOf(Task)))]
			[for (component : ComponentsReference | task.oclAsType(Task).components)]
	[componentsReferenceName(component)/]
			[/for]
		[/for]
	[/for]
)))

;Concretizations
(declare-sort TaskConcretization)
(declare-sort GoalConcretization)
(declare-sort SoftGoalConcretization)
(declare-sort MeansEndConcretization)
(declare-sort DecompositionConcretization)
(declare-fun task (Task TaskConcretization) Bool)
(declare-fun goal (Goal GoalConcretization) Bool)
(declare-fun softgoal (SoftGoal SoftGoalConcretization) Bool)
(declare-fun meansend (MeansEnd MeansEndConcretization) Bool)
(declare-fun meansendSrc (MeansEndConcretization) TaskConcretization)
(declare-fun meansendTgt (MeansEndConcretization) GoalConcretization)
(declare-fun decomposition (Decomposition DecompositionConcretization) Bool)
(declare-fun decompositionType (DecompositionConcretization) Int)
(declare-fun decompositionSrc (DecompositionConcretization) TaskConcretization)
(declare-fun decompositionTgt (DecompositionConcretization) TaskConcretization)
(declare-fun decompositionTgt (DecompositionConcretization) GoalConcretization)
(declare-fun decompositionTgt (DecompositionConcretization) SoftGoalConcretization)
[/template]

[template private encodeAnalysis(istar : IStar)]

;Analysis
(declare-fun inited (TaskConcretization) Bool)
(declare-fun inited (GoalConcretization) Bool)
(declare-fun inited (SoftGoalConcretization) Bool)
(declare-fun fs (TaskConcretization) Bool)
(declare-fun fs (GoalConcretization) Bool)
(declare-fun fs (SoftGoalConcretization) Bool)
(declare-fun fs (MeansEndConcretization) Bool)
(declare-fun fs (DecompositionConcretization) Bool)
(declare-fun ps (TaskConcretization) Bool)
(declare-fun ps (GoalConcretization) Bool)
(declare-fun ps (SoftGoalConcretization) Bool)
(declare-fun ps (MeansEndConcretization) Bool)
(declare-fun ps (DecompositionConcretization) Bool)
(declare-fun un (TaskConcretization) Bool)
(declare-fun un (GoalConcretization) Bool)
(declare-fun un (SoftGoalConcretization) Bool)
(declare-fun un (MeansEndConcretization) Bool)
(declare-fun un (DecompositionConcretization) Bool)
(declare-fun co (TaskConcretization) Bool)
(declare-fun co (GoalConcretization) Bool)
(declare-fun co (SoftGoalConcretization) Bool)
(declare-fun co (MeansEndConcretization) Bool)
(declare-fun co (DecompositionConcretization) Bool)
(declare-fun pd (TaskConcretization) Bool)
(declare-fun pd (GoalConcretization) Bool)
(declare-fun pd (SoftGoalConcretization) Bool)
(declare-fun pd (MeansEndConcretization) Bool)
(declare-fun pd (DecompositionConcretization) Bool)
(declare-fun fd (TaskConcretization) Bool)
(declare-fun fd (GoalConcretization) Bool)
(declare-fun fd (SoftGoalConcretization) Bool)
(declare-fun fd (MeansEndConcretization) Bool)
(declare-fun fd (DecompositionConcretization) Bool)
(assert (forall ((mec MeansEndConcretization)) (= (fs mec)
	(fs (meansendSrc mec))
)))
(assert (forall ((mec MeansEndConcretization)) (= (ps mec)
	(ps (meansendSrc mec))
)))
(assert (forall ((mec MeansEndConcretization)) (= (un mec)
	(un (meansendSrc mec))
)))
(assert (forall ((mec MeansEndConcretization)) (= (co mec)
	(co (meansendSrc mec))
)))
(assert (forall ((mec MeansEndConcretization)) (= (pd mec)
	(pd (meansendSrc mec))
)))
(assert (forall ((mec MeansEndConcretization)) (= (fd mec)
	(fd (meansendSrc mec))
)))
(assert (forall ((dc DecompositionConcretization)) (= (fs dc)
	(ite (= (decompositionType dc) DECOMPOSITION_TASK)
		(fs ((as decompositionTgt (TaskConcretization)) dc))
		(ite (= (decompositionType dc) DECOMPOSITION_GOAL)
			(fs ((as decompositionTgt (GoalConcretization)) dc))
			(fs ((as decompositionTgt (SoftGoalConcretization)) dc))
		)
	)
)))
(assert (forall ((dc DecompositionConcretization)) (= (ps dc)
	(ite (= (decompositionType dc) DECOMPOSITION_TASK)
		(ps ((as decompositionTgt (TaskConcretization)) dc))
		(ite (= (decompositionType dc) DECOMPOSITION_GOAL)
			(ps ((as decompositionTgt (GoalConcretization)) dc))
			(ps ((as decompositionTgt (SoftGoalConcretization)) dc))
		)
	)
)))
(assert (forall ((dc DecompositionConcretization)) (= (un dc)
	(ite (= (decompositionType dc) DECOMPOSITION_TASK)
		(un ((as decompositionTgt (TaskConcretization)) dc))
		(ite (= (decompositionType dc) DECOMPOSITION_GOAL)
			(un ((as decompositionTgt (GoalConcretization)) dc))
			(un ((as decompositionTgt (SoftGoalConcretization)) dc))
		)
	)
)))
(assert (forall ((dc DecompositionConcretization)) (= (co dc)
	(ite (= (decompositionType dc) DECOMPOSITION_TASK)
		(co ((as decompositionTgt (TaskConcretization)) dc))
		(ite (= (decompositionType dc) DECOMPOSITION_GOAL)
			(co ((as decompositionTgt (GoalConcretization)) dc))
			(co ((as decompositionTgt (SoftGoalConcretization)) dc))
		)
	)
)))
(assert (forall ((dc DecompositionConcretization)) (= (pd dc)
	(ite (= (decompositionType dc) DECOMPOSITION_TASK)
		(pd ((as decompositionTgt (TaskConcretization)) dc))
		(ite (= (decompositionType dc) DECOMPOSITION_GOAL)
			(pd ((as decompositionTgt (GoalConcretization)) dc))
			(pd ((as decompositionTgt (SoftGoalConcretization)) dc))
		)
	)
)))
(assert (forall ((dc DecompositionConcretization)) (= (fd dc)
	(ite (= (decompositionType dc) DECOMPOSITION_TASK)
		(fd ((as decompositionTgt (TaskConcretization)) dc))
		(ite (= (decompositionType dc) DECOMPOSITION_GOAL)
			(fd ((as decompositionTgt (GoalConcretization)) dc))
			(fd ((as decompositionTgt (SoftGoalConcretization)) dc))
		)
	)
)))
[/template]

[template private encodeConstraints(istar : IStar)]

;Complete Model
(assert	(forall ((tc TaskConcretization)) (or
	[for (actor : Actor | istar.actors)]
		[for (task : IntentionalElement | actor.intentionalElements->select(oclIsTypeOf(Task)))]
	(task [intentionalElementName(task)/] tc)
		[/for]
	[/for]
)))
(assert (forall ((gc GoalConcretization)) (or
	[for (actor : Actor | istar.actors)]
		[for (goal : IntentionalElement | actor.intentionalElements->select(oclIsTypeOf(Goal)))]
	(goal [intentionalElementName(goal)/] gc)
		[/for]
	[/for]
)))
(assert (forall ((sgc SoftGoalConcretization)) (or
	[for (actor : Actor | istar.actors)]
		[for (softgoal : IntentionalElement | actor.intentionalElements->select(oclIsTypeOf(SoftGoal)))]
	(softgoal [intentionalElementName(softgoal)/] sgc)
		[/for]
	[/for]
)))
(assert (forall ((mec MeansEndConcretization)) (or
	[for (actor : Actor | istar.actors)]
		[for (task : IntentionalElement | actor.intentionalElements->select(oclIsTypeOf(Task)))]
			[for (end : EndReference | task.oclAsType(Task).end)]
	(meansend [endReferenceName(end)/] mec)
			[/for]
		[/for]
	[/for]
)))
(assert (forall ((dc DecompositionConcretization)) (or
	[for (actor : Actor | istar.actors)]
		[for (task : IntentionalElement | actor.intentionalElements->select(oclIsTypeOf(Task)))]
			[for (component : ComponentsReference | task.oclAsType(Task).components)]
	(decomposition [componentsReferenceName(component)/] dc)
			[/for]
		[/for]
	[/for]
)))

;Model Elements
	[for (actor : Actor | istar.actors)]
		[for (task : IntentionalElement | actor.intentionalElements->select(oclIsTypeOf(Task)))]
[encodeInitialAnalysis(task, 'TaskConcretization', 'task', intentionalElementName(task))/]
			[if (not task.may)]
[encodeMayConstraint('TaskConcretization', 'task', intentionalElementName(task))/]
			[/if]
			[if (not task.set)]
[encodeSetConstraint('TaskConcretization', 'task', intentionalElementName(task))/]
			[/if]
			[if (not task.var)]
				[for (actor2 : Actor | istar.actors)]
					[for (task2 : IntentionalElement | actor2.intentionalElements->select(oclIsTypeOf(Task)))]
						[if (not (task.name = task2.name))]
[encodeVarConstraint('TaskConcretization', 'task', intentionalElementName(task), intentionalElementName(task2))/]
						[/if]
					[/for]
				[/for]
			[/if]
		[/for]
	[/for]
	[for (actor : Actor | istar.actors)]
		[for (goal : IntentionalElement | actor.intentionalElements->select(oclIsTypeOf(Goal)))]
[encodeInitialAnalysis(goal, 'GoalConcretization', 'goal', intentionalElementName(goal))/]
			[if (not goal.may)]
[encodeMayConstraint('GoalConcretization', 'goal', intentionalElementName(goal))/]
			[/if]
			[if (not goal.set)]
[encodeSetConstraint('GoalConcretization', 'goal', intentionalElementName(goal))/]
			[/if]
			[if (not goal.var)]
				[for (actor2 : Actor | istar.actors)]
					[for (goal2 : IntentionalElement | actor2.intentionalElements->select(oclIsTypeOf(Goal)))]
						[if (not (goal.name = goal2.name))]
[encodeVarConstraint('GoalConcretization', 'goal', intentionalElementName(goal), intentionalElementName(goal2))/]
						[/if]
					[/for]
				[/for]
			[/if]
		[/for]
	[/for]
	[for (actor : Actor | istar.actors)]
		[for (softgoal : IntentionalElement | actor.intentionalElements->select(oclIsTypeOf(SoftGoal)))]
[encodeInitialAnalysis(softgoal, 'SoftGoalConcretization', 'softgoal', intentionalElementName(softgoal))/]
			[if (not softgoal.may)]
[encodeMayConstraint('SoftGoalConcretization', 'softgoal', intentionalElementName(softgoal))/]
			[/if]
			[if (not softgoal.set)]
[encodeSetConstraint('SoftGoalConcretization', 'softgoal', intentionalElementName(softgoal))/]
			[/if]
			[if (not softgoal.var)]
				[for (actor2 : Actor | istar.actors)]
					[for (softgoal2 : IntentionalElement | actor2.intentionalElements->select(oclIsTypeOf(SoftGoal)))]
						[if (not (softgoal.name = softgoal2.name))]
[encodeVarConstraint('SoftGoalConcretization', 'softgoal', intentionalElementName(softgoal), intentionalElementName(softgoal2))/]
						[/if]
					[/for]
				[/for]
			[/if]
		[/for]
	[/for]
	[for (actor : Actor | istar.actors)]
		[for (task : IntentionalElement | actor.intentionalElements->select(oclIsTypeOf(Task)))]
			[for (end : EndReference | task.oclAsType(Task).end)]
[encodeMetamodelConstraint('MeansEndConcretization', 'meansend', null, endReferenceName(end), 'task', intentionalElementName(end.src), 'goal', intentionalElementName(end.tgt))/]
				[if (not end.may)]
[encodeMayConstraint('MeansEndConcretization', 'meansend', endReferenceName(end))/]
				[/if]
				[if (not end.set)]
[encodeSetConstraint('MeansEndConcretization', 'meansend', endReferenceName(end))/]
				[/if]
				[if (not end.var)]
					[for (actor2 : Actor | istar.actors)]
						[for (task2 : IntentionalElement | actor2.intentionalElements->select(oclIsTypeOf(Task)))]
							[for (end2 : EndReference | task2.oclAsType(Task).end)]
								[if (not (endReferenceName(end) = endReferenceName(end2)))]
[encodeVarConstraint('MeansEndConcretization', 'meansend', endReferenceName(end), endReferenceName(end2))/]
								[/if]
							[/for]
						[/for]
					[/for]
				[/if]
			[/for]
		[/for]
	[/for]
	[for (actor : Actor | istar.actors)]
		[for (task : IntentionalElement | actor.intentionalElements->select(oclIsTypeOf(Task)))]
			[for (component : ComponentsReference | task.oclAsType(Task).components)]
				[if (component.tgt.oclIsTypeOf(Task))]
[encodeMetamodelType('DecompositionConcretization', 'decomposition', componentsReferenceName(component), 'DECOMPOSITION_TASK')/]
[encodeMetamodelConstraint('DecompositionConcretization', 'decomposition', 'TaskConcretization', componentsReferenceName(component), 'task', intentionalElementName(component.src), 'task', intentionalElementName(component.tgt))/]
				[elseif (component.tgt.oclIsTypeOf(Goal))]
[encodeMetamodelType('DecompositionConcretization', 'decomposition', componentsReferenceName(component), 'DECOMPOSITION_GOAL')/]
[encodeMetamodelConstraint('DecompositionConcretization', 'decomposition', 'GoalConcretization', componentsReferenceName(component), 'task', intentionalElementName(component.src), 'goal', intentionalElementName(component.tgt))/]
				[elseif (component.tgt.oclIsTypeOf(SoftGoal))]
[encodeMetamodelType('DecompositionConcretization', 'decomposition', componentsReferenceName(component), 'DECOMPOSITION_SOFTGOAL')/]
[encodeMetamodelConstraint('DecompositionConcretization', 'decomposition', 'SoftGoalConcretization', componentsReferenceName(component), 'task', intentionalElementName(component.src), 'softgoal', intentionalElementName(component.tgt))/]
				[/if]
				[if (not component.may)]
[encodeMayConstraint('DecompositionConcretization', 'decomposition', componentsReferenceName(component))/]
				[/if]
				[if (not component.set)]
[encodeSetConstraint('DecompositionConcretization', 'decomposition', componentsReferenceName(component))/]
				[/if]
				[if (not component.var)]
					[for (actor2 : Actor | istar.actors)]
						[for (task2 : IntentionalElement | actor2.intentionalElements->select(oclIsTypeOf(Task)))]
							[for (component2 : ComponentsReference | task2.oclAsType(Task).components)]
								[if (not (componentsReferenceName(component) = componentsReferenceName(component2)))]
[encodeVarConstraint('DecompositionConcretization', 'decomposition', componentsReferenceName(component), componentsReferenceName(component2))/]
								[/if]
							[/for]
						[/for]
					[/for]
				[/if]
			[/for]
		[/for]
	[/for]
[/template]

[template private encodePropagation(istar : IStar)]

;MeansEnd Propagation
(assert	(forall ((gc GoalConcretization)) (=> (not (inited gc)) (= (fs gc) (ite
	(exists ((mec MeansEndConcretization)) (and (= (meansendTgt mec) gc) (fs mec)))
	true
	false
)))))
(assert	(forall ((gc GoalConcretization)) (=> (not (inited gc)) (= (ps gc) (ite
	(and (exists ((mec1 MeansEndConcretization)) (and (= (meansendTgt mec1) gc) (ps mec1))) (not (exists ((mec2 MeansEndConcretization)) (and (= (meansendTgt mec2) gc) (fs mec2)))))
	true
	false
)))))
(assert	(forall ((gc GoalConcretization)) (=> (not (inited gc)) (= (un gc) (ite
	(and (exists ((mec1 MeansEndConcretization)) (and (= (meansendTgt mec1) gc) (un mec1))) (not (exists ((mec2 MeansEndConcretization)) (and (= (meansendTgt mec2) gc) (or (fs mec2) (ps mec2))))))
	true
	false
)))))
(assert	(forall ((gc GoalConcretization)) (=> (not (inited gc)) (= (co gc) (ite
	(and (exists ((mec1 MeansEndConcretization)) (and (= (meansendTgt mec1) gc) (co mec1))) (not (exists ((mec2 MeansEndConcretization)) (and (= (meansendTgt mec2) gc) (or (fs mec2) (ps mec2) (un mec2))))))
	true
	false
)))))
(assert	(forall ((gc GoalConcretization)) (=> (not (inited gc)) (= (pd gc) (ite
	(and (exists ((mec1 MeansEndConcretization)) (and (= (meansendTgt mec1) gc) (pd mec1))) (not (exists ((mec2 MeansEndConcretization)) (and (= (meansendTgt mec2) gc) (or (fs mec2) (ps mec2) (un mec2) (co mec2))))))
	true
	false
)))))
(assert	(forall ((gc GoalConcretization)) (=> (not (inited gc)) (= (fd gc) (ite
	(and (exists ((mec1 MeansEndConcretization)) (and (= (meansendTgt mec1) gc) (fd mec1))) (not (exists ((mec2 MeansEndConcretization)) (and (= (meansendTgt mec2) gc) (or (fs mec2) (ps mec2) (un mec2) (co mec2) (pd mec2))))))
	true
	false
)))))

;Decomposition Propagation
(assert (forall ((tc TaskConcretization)) (=> (not (inited tc)) (= (fd tc) (ite
	(exists ((dc DecompositionConcretization)) (and (= (decompositionSrc dc) tc) (fd dc)))
	true
	false
)))))
(assert (forall ((tc TaskConcretization)) (=> (not (inited tc))  (= (pd tc) (ite
	(and (exists ((dc1 DecompositionConcretization)) (and (= (decompositionSrc dc1) tc) (pd dc1))) (not (exists ((dc2 DecompositionConcretization)) (and (= (decompositionSrc dc2) tc) (fd dc2)))))
	true
	false
)))))
(assert (forall ((tc TaskConcretization)) (=> (not (inited tc))  (= (co tc) (ite
	(and (exists ((dc1 DecompositionConcretization)) (and (= (decompositionSrc dc1) tc) (co dc1))) (not (exists ((dc2 DecompositionConcretization)) (and (= (decompositionSrc dc2) tc) (or (fd dc2) (pd dc2))))))
	true
	false
)))))
(assert (forall ((tc TaskConcretization)) (=> (not (inited tc))  (= (un tc) (ite
	(and (exists ((dc1 DecompositionConcretization)) (and (= (decompositionSrc dc1) tc) (un dc1))) (not (exists ((dc2 DecompositionConcretization)) (and (= (decompositionSrc dc2) tc) (or (fd dc2) (pd dc2) (co dc2))))))
	true
	false
)))))
(assert (forall ((tc TaskConcretization)) (=> (not (inited tc))  (= (ps tc) (ite
	(and (exists ((dc1 DecompositionConcretization)) (and (= (decompositionSrc dc1) tc) (ps dc1))) (not (exists ((dc2 DecompositionConcretization)) (and (= (decompositionSrc dc2) tc) (or (fd dc2) (pd dc2) (co dc2) (un dc2))))))
	true
	false
)))))
(assert (forall ((tc TaskConcretization)) (=> (not (inited tc))  (= (fs tc) (ite
	(and (exists ((dc1 DecompositionConcretization)) (and (= (decompositionSrc dc1) tc) (fs dc1))) (not (exists ((dc2 DecompositionConcretization)) (and (= (decompositionSrc dc2) tc) (or (fd dc2) (pd dc2) (co dc2) (un dc2) (ps dc2))))))
	true
	false
)))))
[/template]

[template public encodeIStarMAVO(istar : IStar)]
[comment @main/]
[file ('encoding.smt2', false, 'UTF-8')]
[encodeConstants(istar)/]
[encodeModel(istar)/]
[encodeAnalysis(istar)/]
[encodeConstraints(istar)/]
[encodePropagation(istar)/]
[/file]
[/template]
