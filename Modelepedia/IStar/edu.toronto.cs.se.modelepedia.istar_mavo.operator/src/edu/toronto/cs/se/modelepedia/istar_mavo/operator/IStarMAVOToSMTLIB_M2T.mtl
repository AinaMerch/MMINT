[comment encoding = UTF-8 /]
[module IStarMAVOToSMTLIB_M2T('http://se.cs.toronto.edu/mmtf/MAVO', 'http://se.cs.toronto.edu/modelepedia/IStar_MAVO')]
[import edu::toronto::cs::se::modelepedia::istar_mavo::operator::EcoreToSMTLIB_M2T /]

[query private getAllIntentions(istar : IStar) : Collection(Intention) =
	istar.actors->collect(intentions)->addAll(istar.dependums)
/]

[query private getAllIntentions(istar : IStar, intentionClass : String) : Collection(Intention) =
	istar.actors->collect(intentions)->addAll(istar.dependums)->select(eClass().name = intentionClass)
/]

[query private getActorIntentions(actor : Actor, intentionClass : String) : Collection(Intention) =
	actor.intentions->select(eClass().name = intentionClass)
/]

[query private getDependumIntentions(istar : IStar, intentionClass : String) : Collection(Intention) =
	istar.dependums->select(eClass().name = intentionClass)
/]

[query private getAllIntentionLinks(istar : IStar) : Collection(IntentionLink) =
	istar.actors->collect(intentions)->collect(linksAsSrc)
/]

[query private getAllIntentionLinks(istar : IStar, intentionLinkClass : String) : Collection(IntentionLink) =
	istar.actors->collect(intentions)->collect(linksAsSrc)->select(eClass().name = intentionLinkClass)
/]

[query private getActorIntentionLinks(actor : Actor, intentionLinkClass : String) : Collection(IntentionLink) =
	actor.intentions->collect(linksAsSrc)->select(eClass().name = intentionLinkClass)
/]

[query private getAllDependerLinks(istar : IStar) : Collection(DependerLink) =
	istar.dependums->collect(dependerLinks)
/]

[query private getAllDependeeLinks(istar : IStar) : Collection(DependeeLink) =
	istar.dependums->collect(dependeeLinks)
/]

[query private nodeName(node : DependencyEndpoint) : String =
	node.name.replaceAll(' ', '')
/]

[query private edgeName(intention : Intention) : String =
	nodeName(intention.eContainer().oclAsType(Actor)) + '2' + nodeName(intention)
/]

[query private edgeName(intentionLink : IntentionLink) : String =
	nodeName(intentionLink.src) + '2' + nodeName(intentionLink.tgt)
/]

[query private edgeName(dependerLink : DependerLink) : String =
	nodeName(dependerLink.depender) + '2' + nodeName(dependerLink.dependum)
/]

[query private edgeName(dependeeLink : DependeeLink) : String =
	nodeName(dependeeLink.dependum) + '2' + nodeName(dependeeLink.dependee)
/]

[template private encodeIntentions(istar : IStar, intentionClass : String, firstIndex : Integer)]
[for (intention : Intention | getAllIntentions(istar, intentionClass))]
(declare-const [nodeName(intention)/] Node)
(assert (= [nodeName(intention)/] [firstIndex + i/]))
[/for]
[/template]

[template private encodeIntentionLinks(istar : IStar, intentionLinkClass : String, firstIndex : Integer)]
[for (intentionLink : IntentionLink | getAllIntentionLinks(istar, intentionLinkClass))]
(declare-const [edgeName(intentionLink)/] Edge)
(assert (= [edgeName(intentionLink)/] [firstIndex + i/]))
[/for]
[/template]

[template private encodeInitialAnalysis(intention : Intention)]
;[nodeName(intention)/] initial analysis tag
(assert (forall ((c [intention.eClass().name/])) (=>
	(node [nodeName(intention)/] c)
[if (intention.fullySatisfied or intention.partiallySatisfied or intention.unknown or intention.conflict or intention.partiallyDenied or intention.fullyDenied or intention.noLabel)]
	(and
		(= (fs c) [if (intention.fullySatisfied)]true[else]false[/if])
		(= (ps c) [if (intention.partiallySatisfied)]true[else]false[/if])
		(= (un c) [if (intention.unknown)]true[else]false[/if])
		(= (co c) [if (intention.conflict)]true[else]false[/if])
		(= (pd c) [if (intention.partiallyDenied)]true[else]false[/if])
		(= (fd c) [if (intention.fullyDenied)]true[else]false[/if])
		(= (n c) [if (intention.noLabel)]true[else]false[/if])
		(= (inited c) true)
	)
[else]
	(= (inited c) false)
[/if]
)))
[/template]

[template private encodeOWIntentionConstraint(istar : IStar, intentionClass : String)]
;[intentionClass/]s are Complete
(assert (forall ((c [intentionClass/])) (or
[for (intention : Intention | getAllIntentions(istar, intentionClass))]
	(node [nodeName(intention)/] c)
[/for]
)))
[/template]

[template private encodeOWIntentionLinkConstraint(istar : IStar, intentionLinkClass : String)]
;[intentionLinkClass/]s are Complete
(assert (forall ((c [intentionLinkClass/])) (or
[for (intentionLink : IntentionLink | getAllIntentionLinks(istar, intentionLinkClass))]
	(edge [edgeName(intentionLink)/] c)
[/for]
)))
[/template]

[template private encodeMConstraint(sort : String, fun : String, name : String)]
;[name/] Exists
(assert	(exists ((c [sort/])) ([fun/] [name/] c)))
[/template]

[template private encodeMIntentionConstraint(intention : Intention)]
[encodeMConstraint(intention.eClass().name, 'node', nodeName(intention))/]
[/template]

[template private encodeMIntentionLinkConstraint(intentionLink : IntentionLink)]
[encodeMConstraint(intentionLink.eClass().name, 'edge', edgeName(intentionLink))/]
[/template]

[template private encodeMDependerLinkConstraint(dependerLink : DependerLink)]
[encodeMConstraint('DependerLink', 'edge', edgeName(dependerLink))/]
[/template]

[template private encodeMDependeeLinkConstraint(dependeeLink : DependeeLink)]
[encodeMConstraint('DependeeLink', 'edge', edgeName(dependeeLink))/]
[/template]

[template private encodeSConstraint(sort : String, fun : String, name : String)]
;[name/] is Unique
(assert	(forall ((c1 [sort/]) (c2 [sort/])) (=>
	(and ([fun/] [name/] c1) ([fun/] [name/] c2))
	(= c1 c2)
)))
[/template]

[template private encodeSIntentionConstraint(intention : Intention)]
[encodeSConstraint(intention.eClass().name, 'node', nodeName(intention))/]
[/template]

[template private encodeSIntentionLinkConstraint(intentionLink : IntentionLink)]
[encodeSConstraint(intentionLink.eClass().name, 'edge', edgeName(intentionLink))/]
[/template]

[template private encodeSDependerLinkConstraint(dependerLink : DependerLink)]
[encodeSConstraint('DependerLink', 'edge', edgeName(dependerLink))/]
[/template]

[template private encodeSDependeeLinkConstraint(dependeeLink : DependeeLink)]
[encodeSConstraint('DependeeLink', 'edge', edgeName(dependeeLink))/]
[/template]

[template private encodeVConstraint(sort : String, fun : String, name1 : String, name2 : String)]
;[name1/] is Distinct from [name2/]
(assert	(forall ((c [sort/])) (=>
	([fun/] [name1/] c)
	(not ([fun/] [name2/] c))
)))
[/template]

[template private encodeVConstraintPreamble(sort : String, fun : String, name : String)]
;[name/] is Distinct
(assert	(forall ((c [sort/])) (=>
	([fun/] [name/] c)
	(not (or
[/template]

[template private encodeVConstraintBody(fun : String, name : String)]
		([fun/] [name/] c)
[/template]

[template private encodeVConstraintPostamble(traceability : OclAny)]
	))
)))
[/template]

[template private encodeVIntentionConstraint(intention1 : Intention, intention2 : Intention)]
[encodeVConstraint(intention1.eClass().name, 'node', nodeName(intention1), nodeName(intention2))/]
[/template]

[template private encodeVIntentionLinkConstraint(intentionLink1 : IntentionLink, intentionLink2 : IntentionLink)]
[encodeVConstraint(intentionLink1.eClass().name, 'edge', edgeName(intentionLink1), edgeName(intentionLink2))/]
[/template]

[template private encodeVDependerLinkConstraint(dependerLink1 : DependerLink, dependerLink2 : DependerLink)]
[encodeVConstraint('DependerLink', 'edge', edgeName(dependerLink1), edgeName(dependerLink2))/]
[/template]

[template private encodeVDependeeLinkConstraint(dependeeLink1 : DependeeLink, dependeeLink2 : DependeeLink)]
[encodeVConstraint('DependeeLink', 'edge', edgeName(dependeeLink1), edgeName(dependeeLink2))/]
[/template]

[template private encodeMAVIntentionConstraints(istar : IStar, intention : Intention)]
[if (not intention.may)]
[encodeMIntentionConstraint(intention)/]
[/if]
[if (not intention.set)]
[encodeSIntentionConstraint(intention)/]
[/if]
[let unmergeableIntentions : Sequence(String) = getUnmergeableModelObjects(istar, intention)]
[if (not unmergeableIntentions->isEmpty())]
[encodeVConstraintPreamble(intention.eClass().name, 'node', nodeName(intention))/]
	[for (unmergeableIntention : String | unmergeableIntentions)]
[encodeVConstraintBody('node', unmergeableIntention)/]
	[/for]
[encodeVConstraintPostamble()/]
[/if]
[/let]
[/template]

[template private encodeMAVIntentionLinkConstraint(istar : IStar, intentionLink : IntentionLink)]
[if (not intentionLink.may)]
[encodeMIntentionLinkConstraint(intentionLink)/]
[/if]
[if (not intentionLink.set)]
[encodeSIntentionLinkConstraint(intentionLink)/]
[/if]
[let unmergeableIntentionLinks : Sequence(String) = getUnmergeableModelObjects(istar, intentionLink)]
[if (not unmergeableIntentionLinks->isEmpty())]
[encodeVConstraintPreamble(intentionLink.eClass().name, 'edge', edgeName(intentionLink))/]
	[for (unmergeableIntentionLink : String | unmergeableIntentionLinks)]
[encodeVConstraintBody('edge', unmergeableIntentionLink)/]
	[/for]
[encodeVConstraintPostamble()/]
[/if]
[/let]
[/template]

[template private encodeModelConstant(sort : String, fun : String, name : String, funConst : String, const : String)]
;[name/] [funConst/] constant
(assert (forall ((c [sort/])) (=>
	([fun/] [name/] c)
	(= ([funConst/] c) [const/])
)))
[/template]

[template private encodeIntentionLinkConstant(intentionLink : IntentionLink, funConst : String, const : String)]
[encodeModelConstant(intentionLink.eClass().name, 'edge', edgeName(intentionLink), funConst, const)/]
[/template]

[template private encodeEdgeConstraint(sort : String, name : String, classSrc : String, nameSrc : String, classTgt : String, nameTgt : String)]
;[name/] endpoints
(assert (forall ((c [sort/])) (=>
	(edge [name/] c)
	(and
		(node [nameSrc/] ([if (classSrc = '')]src[else](as src ([classSrc/]))[/if] c))
		(node [nameTgt/] ([if (classTgt = '')]tgt[else](as tgt ([classTgt/]))[/if] c))
	)
)))
[/template]

[template private encodeIntentionLinkConstraint(intentionLink : IntentionLink, multipleClassSrc : Boolean, multipleClassTgt : Boolean)]
	[let classSrc : String = if multipleClassSrc then intentionLink.src.eClass().name else '' endif]
	[let classTgt : String = if multipleClassTgt then intentionLink.tgt.eClass().name else '' endif]
[encodeEdgeConstraint(intentionLink.eClass().name, edgeName(intentionLink), classSrc, nodeName(intentionLink.src), classTgt, nodeName(intentionLink.tgt))/]
	[if (multipleClassSrc)]
[encodeIntentionLinkConstant(intentionLink, 'srcType', classSrc.toUpper())/]
	[/if]
	[if (multipleClassTgt)]
[encodeIntentionLinkConstant(intentionLink, 'tgtType', classTgt.toUpper())/]
	[/if]
	[/let]
	[/let]
[/template]

[template private encodeConstants(istar : IStar)]
;Endpoint Types
(define-sort NodeType () Int)
(declare-const TASK NodeType)
(declare-const GOAL NodeType)
(declare-const SOFTGOAL NodeType)
(declare-const RESOURCE NodeType)
(assert (= TASK 1))
(assert (= GOAL 2))
(assert (= SOFTGOAL 3))
(assert (= RESOURCE 4))

;Contribution Types
(define-sort ContributionType () Int)
(declare-const MAKE ContributionType)
(declare-const HELP ContributionType)
(declare-const SOMEPLUS ContributionType)
(declare-const BREAK ContributionType)
(declare-const HURT ContributionType)
(declare-const SOMEMINUS ContributionType)
(declare-const UNKNOWN ContributionType)
(assert (= MAKE 11))
(assert (= HELP 12))
(assert (= SOMEPLUS 13))
(assert (= BREAK 14))
(assert (= HURT 15))
(assert (= SOMEMINUS 16))
(assert (= UNKNOWN 17))
[/template]

[template private encodeModel(istar : IStar)]

;Model
(define-sort Node () Int)
(define-sort Edge () Int)

[let numActors : Integer = 100 + istar.actors->size()]
[let numTasks : Integer = numActors + getAllIntentions(istar, 'Task')->size()]
[let numGoals : Integer = numTasks + getAllIntentions(istar, 'Goal')->size()]
[let numSoftGoals : Integer = numGoals + getAllIntentions(istar, 'SoftGoal')->size()]
[let numResources : Integer = numSoftGoals + getAllIntentions(istar, 'Resource')->size()]
[let numContainments : Integer = numResources + istar.actors->collect(intentions)->size()]
[let numMeansEnds : Integer = numContainments + getAllIntentionLinks(istar, 'MeansEnd')->size()]
[let numDecompositions : Integer = numMeansEnds + getAllIntentionLinks(istar, 'Decomposition')->size()]
[let numContributions : Integer = numDecompositions + getAllIntentionLinks(istar, 'Contribution')->size()]
[let numDependers : Integer = numContributions + getAllDependerLinks(istar)->select(not depender.oclIsTypeOf(Actor))->size()]
[for (actor : Actor | istar.actors)]
(declare-const [nodeName(actor)/] Node)
(assert (= [nodeName(actor)/] [100 + i/]))
[/for]
[encodeIntentions(istar, 'Task', numActors)/]
[encodeIntentions(istar, 'Goal', numTasks)/]
[encodeIntentions(istar, 'SoftGoal', numGoals)/]
[encodeIntentions(istar, 'Resource', numSoftGoals)/]
[for (intention : Intention | istar.actors->collect(intentions))]
(declare-const [edgeName(intention)/] Edge)
(assert (= [edgeName(intention)/] [numResources + i/]))
[/for]
[encodeIntentionLinks(istar, 'MeansEnd', numContainments)/]
[encodeIntentionLinks(istar, 'Decomposition', numMeansEnds)/]
[encodeIntentionLinks(istar, 'Contribution', numDecompositions)/]
[for (dependerLink : DependerLink | getAllDependerLinks(istar)->select(not depender.oclIsTypeOf(Actor)))]
(declare-const [edgeName(dependerLink)/] Edge)
(assert (= [edgeName(dependerLink)/] [numContributions + i/]))
[/for]
[for (dependeeLink : DependeeLink | getAllDependeeLinks(istar)->select(not dependee.oclIsTypeOf(Actor)))]
(declare-const [edgeName(dependeeLink)/] Edge)
(assert (= [edgeName(dependeeLink)/] [numDependers + i/]))
[/for]
[/let]
[/let]
[/let]
[/let]
[/let]
[/let]
[/let]
[/let]
[/let]
[/let]

;Concretizations
(declare-sort Actor)
(declare-sort Task)
(declare-sort Goal)
(declare-sort SoftGoal)
(declare-sort Resource)
(declare-sort Containment)
(declare-sort MeansEnd)
(declare-sort Decomposition)
(declare-sort Contribution)
(declare-sort DependerLink)
(declare-sort DependeeLink)
(declare-fun node (Node Actor) Bool)
(declare-fun node (Node Task) Bool)
(declare-fun node (Node Goal) Bool)
(declare-fun node (Node SoftGoal) Bool)
(declare-fun node (Node Resource) Bool)
(declare-fun edge (Edge Containment) Bool)
(declare-fun tgtType (Containment) NodeType)
(declare-fun src (Containment) Actor)
(declare-fun tgt (Containment) Task)
(declare-fun tgt (Containment) Goal)
(declare-fun tgt (Containment) SoftGoal)
(declare-fun tgt (Containment) Resource)
(declare-fun edge (Edge MeansEnd) Bool)
(declare-fun src (MeansEnd) Task)
(declare-fun tgt (MeansEnd) Goal)
(declare-fun edge (Edge Decomposition) Bool)
(declare-fun srcType (Decomposition) NodeType)
(declare-fun src (Decomposition) Task)
(declare-fun src (Decomposition) Goal)
(declare-fun src (Decomposition) SoftGoal)
(declare-fun src (Decomposition) Resource)
(declare-fun tgt (Decomposition) Task)
(declare-fun edge (Edge Contribution) Bool)
(declare-fun srcType (Contribution) NodeType)
(declare-fun type (Contribution) ContributionType)
(declare-fun src (Contribution) Task)
(declare-fun src (Contribution) Goal)
(declare-fun src (Contribution) SoftGoal)
(declare-fun src (Contribution) Resource)
(declare-fun tgt (Contribution) SoftGoal)
(declare-fun edge (Edge DependerLink) Bool)
(declare-fun srcType (DependerLink) NodeType)
(declare-fun tgtType (DependerLink) NodeType)
(declare-fun src (DependerLink) Task)
(declare-fun src (DependerLink) Goal)
(declare-fun src (DependerLink) SoftGoal)
(declare-fun src (DependerLink) Resource)
(declare-fun tgt (DependerLink) Task)
(declare-fun tgt (DependerLink) Goal)
(declare-fun tgt (DependerLink) SoftGoal)
(declare-fun tgt (DependerLink) Resource)
(declare-fun edge (Edge DependeeLink) Bool)
(declare-fun srcType (DependeeLink) NodeType)
(declare-fun tgtType (DependeeLink) NodeType)
(declare-fun src (DependeeLink) Task)
(declare-fun src (DependeeLink) Goal)
(declare-fun src (DependeeLink) SoftGoal)
(declare-fun src (DependeeLink) Resource)
(declare-fun tgt (DependeeLink) Task)
(declare-fun tgt (DependeeLink) Goal)
(declare-fun tgt (DependeeLink) SoftGoal)
(declare-fun tgt (DependeeLink) Resource)
[/template]

[template private encodeAnalysis(istar : IStar)]

;Analysis labels
(declare-fun inited (Task) Bool)
(declare-fun inited (Goal) Bool)
(declare-fun inited (SoftGoal) Bool)
(declare-fun inited (Resource) Bool)
(declare-fun fsSrc (Contribution) Bool)
(declare-fun psSrc (Contribution) Bool)
(declare-fun unSrc (Contribution) Bool)
(declare-fun coSrc (Contribution) Bool)
(declare-fun pdSrc (Contribution) Bool)
(declare-fun fdSrc (Contribution) Bool)
(declare-fun fs (Task) Bool)
(declare-fun fs (Goal) Bool)
(declare-fun fs (SoftGoal) Bool)
(declare-fun fs (Resource) Bool)
(declare-fun fs (MeansEnd) Bool)
(declare-fun fs (Decomposition) Bool)
(declare-fun fs (Contribution) Bool)
(declare-fun fs (DependerLink) Bool)
(declare-fun fs (DependeeLink) Bool)
(declare-fun ps (Task) Bool)
(declare-fun ps (Goal) Bool)
(declare-fun ps (SoftGoal) Bool)
(declare-fun ps (Resource) Bool)
(declare-fun ps (MeansEnd) Bool)
(declare-fun ps (Decomposition) Bool)
(declare-fun ps (Contribution) Bool)
(declare-fun ps (DependerLink) Bool)
(declare-fun ps (DependeeLink) Bool)
(declare-fun un (Task) Bool)
(declare-fun un (Goal) Bool)
(declare-fun un (SoftGoal) Bool)
(declare-fun un (Resource) Bool)
(declare-fun un (MeansEnd) Bool)
(declare-fun un (Decomposition) Bool)
(declare-fun un (Contribution) Bool)
(declare-fun un (DependerLink) Bool)
(declare-fun un (DependeeLink) Bool)
(declare-fun co (Task) Bool)
(declare-fun co (Goal) Bool)
(declare-fun co (SoftGoal) Bool)
(declare-fun co (Resource) Bool)
(declare-fun co (MeansEnd) Bool)
(declare-fun co (Decomposition) Bool)
(declare-fun co (Contribution) Bool)
(declare-fun co (DependerLink) Bool)
(declare-fun co (DependeeLink) Bool)
(declare-fun pd (Task) Bool)
(declare-fun pd (Goal) Bool)
(declare-fun pd (SoftGoal) Bool)
(declare-fun pd (Resource) Bool)
(declare-fun pd (MeansEnd) Bool)
(declare-fun pd (Decomposition) Bool)
(declare-fun pd (Contribution) Bool)
(declare-fun pd (DependerLink) Bool)
(declare-fun pd (DependeeLink) Bool)
(declare-fun fd (Task) Bool)
(declare-fun fd (Goal) Bool)
(declare-fun fd (SoftGoal) Bool)
(declare-fun fd (Resource) Bool)
(declare-fun fd (MeansEnd) Bool)
(declare-fun fd (Decomposition) Bool)
(declare-fun fd (Contribution) Bool)
(declare-fun fd (DependerLink) Bool)
(declare-fun fd (DependeeLink) Bool)
(assert (forall ((c MeansEnd)) (= (fs c) (fs (src c)))))
(assert (forall ((c MeansEnd)) (= (ps c) (ps (src c)))))
(assert (forall ((c MeansEnd)) (= (un c) (un (src c)))))
(assert (forall ((c MeansEnd)) (= (co c) (co (src c)))))
(assert (forall ((c MeansEnd)) (= (pd c) (pd (src c)))))
(assert (forall ((c MeansEnd)) (= (fd c) (fd (src c)))))
(assert (forall ((c Decomposition)) (= (fs c)
	(ite (= (srcType c) TASK)
		(fs ((as src (Task)) c))
		(ite (= (srcType c) GOAL)
			(fs ((as src (Goal)) c))
			(ite (= (srcType c) SOFTGOAL)
				(fs ((as src (SoftGoal)) c))
				(fs ((as src (Resource)) c))
			)
		)
	)
)))
(assert (forall ((c Decomposition)) (= (ps c)
	(ite (= (srcType c) TASK)
		(ps ((as src (Task)) c))
		(ite (= (srcType c) GOAL)
			(ps ((as src (Goal)) c))
			(ite (= (srcType c) SOFTGOAL)
				(ps ((as src (SoftGoal)) c))
				(ps ((as src (Resource)) c))
			)
		)
	)
)))
(assert (forall ((c Decomposition)) (= (un c)
	(ite (= (srcType c) TASK)
		(un ((as src (Task)) c))
		(ite (= (srcType c) GOAL)
			(un ((as src (Goal)) c))
			(ite (= (srcType c) SOFTGOAL)
				(un ((as src (SoftGoal)) c))
				(un ((as src (Resource)) c))
			)
		)
	)
)))
(assert (forall ((c Decomposition)) (= (co c)
	(ite (= (srcType c) TASK)
		(co ((as src (Task)) c))
		(ite (= (srcType c) GOAL)
			(co ((as src (Goal)) c))
			(ite (= (srcType c) SOFTGOAL)
				(co ((as src (SoftGoal)) c))
				(co ((as src (Resource)) c))
			)
		)
	)
)))
(assert (forall ((dc Decomposition)) (= (pd dc)
	(ite (= (srcType dc) TASK)
		(pd ((as src (Task)) dc))
		(ite (= (srcType dc) GOAL)
			(pd ((as src (Goal)) dc))
			(ite (= (srcType dc) SOFTGOAL)
				(pd ((as src (SoftGoal)) dc))
				(pd ((as src (Resource)) dc))
			)
		)
	)
)))
(assert (forall ((c Decomposition)) (= (fd c)
	(ite (= (srcType c) TASK)
		(fd ((as src (Task)) c))
		(ite (= (srcType c) GOAL)
			(fd ((as src (Goal)) c))
			(ite (= (srcType c) SOFTGOAL)
				(fd ((as src (SoftGoal)) c))
				(fd ((as src (Resource)) c))
			)
		)
	)
)))
(assert (forall ((c Contribution)) (= (fsSrc c)
	(ite (= (srcType c) TASK)
		(fs ((as src (Task)) c))
		(ite (= (srcType c) GOAL)
			(fs ((as src (Goal)) c))
			(ite (= (srcType c) SOFTGOAL)
				(fs ((as src (SoftGoal)) c))
				(fs ((as src (Resource)) c))
			)
		)
	)
)))
(assert (forall ((c Contribution)) (= (psSrc c)
	(ite (= (srcType c) TASK)
		(ps ((as src (Task)) c))
		(ite (= (srcType c) GOAL)
			(ps ((as src (Goal)) c))
			(ite (= (srcType c) SOFTGOAL)
				(ps ((as src (SoftGoal)) c))
				(ps ((as src (Resource)) c))
			)
		)
	)
)))
(assert (forall ((c Contribution)) (= (unSrc c)
	(ite (= (srcType c) TASK)
		(un ((as src (Task)) c))
		(ite (= (srcType c) GOAL)
			(un ((as src (Goal)) c))
			(ite (= (srcType c) SOFTGOAL)
				(un ((as src (SoftGoal)) c))
				(un ((as src (Resource)) c))
			)
		)
	)
)))
(assert (forall ((c Contribution)) (= (coSrc c)
	(ite (= (srcType c) TASK)
		(co ((as src (Task)) c))
		(ite (= (srcType c) GOAL)
			(co ((as src (Goal)) c))
			(ite (= (srcType c) SOFTGOAL)
				(co ((as src (SoftGoal)) c))
				(co ((as src (Resource)) c))
			)
		)
	)
)))
(assert (forall ((c Contribution)) (= (pdSrc c)
	(ite (= (srcType c) TASK)
		(pd ((as src (Task)) c))
		(ite (= (srcType c) GOAL)
			(pd ((as src (Goal)) c))
			(ite (= (srcType c) SOFTGOAL)
				(pd ((as src (SoftGoal)) c))
				(pd ((as src (Resource)) c))
			)
		)
	)
)))
(assert (forall ((c Contribution)) (= (fdSrc c)
	(ite (= (srcType c) TASK)
		(fd ((as src (Task)) c))
		(ite (= (srcType c) GOAL)
			(fd ((as src (Goal)) c))
			(ite (= (srcType c) SOFTGOAL)
				(fd ((as src (SoftGoal)) c))
				(fd ((as src (Resource)) c))
			)
		)
	)
)))
(assert (forall ((c Contribution)) (= (fs c)
	(ite (= (type c) MAKE)
		(ite (fsSrc c)
			true
			false
		)
		false
	)
)))
(assert (forall ((c Contribution)) (= (ps c)
	(ite (= (type c) MAKE)
		(ite (psSrc c)
			true
			false
		)
		(ite (or (= (type c) HELP) (= (type c) SOMEPLUS))
			(ite (or (fsSrc c) (psSrc c))
				true
				false
			)
			(ite (or (= (type c) BREAK) (= (type c) HURT) (= (type c) SOMEMINUS))
				(ite (or (pdSrc c) (fdSrc c))
					true
					false
				)
				false
			)
		)
	)
)))
(assert (forall ((c Contribution)) (= (un c)
	(ite (= (type c) UNKNOWN)
		true
		(ite (unSrc c)
			true
			false
		)
	)
)))
(assert (forall ((c Contribution)) (= (co c)
	(ite (= (type c) UNKNOWN)
		false
		(ite (coSrc c)
			true
			false
		)
	)
)))
(assert (forall ((c Contribution)) (= (pd c)
	(ite (= (type c) MAKE)
		(ite (pdSrc c)
			true
			false
		)
		(ite (or (= (type c) HELP) (= (type c) SOMEPLUS))
			(ite (or (pdSrc c) (fdSrc c))
				true
				false
			)
			(ite (= (type c) BREAK)
				(ite (psSrc c)
					true
					false
				)
				(ite (or (= (type c) HURT) (= (type c) SOMEMINUS))
					(ite (or (fsSrc c) (psSrc c))
						true
						false
					)
					false
				)
			)
		)
	)
)))
(assert (forall ((c Contribution)) (= (fd c)
	(ite (= (type c) MAKE)
		(ite (fdSrc c)
			true
			false
		)
		(ite (= (type c) BREAK)
			(ite (fsSrc c)
				true
				false
			)
			false
		)
	)
)))
(assert (forall ((c DependerLink)) (= (fs c)
	(ite (= (tgtType c) TASK)
		(fs ((as tgt (Task)) c))
		(ite (= (tgtType c) GOAL)
			(fs ((as tgt (Goal)) c))
			(ite (= (tgtType c) SOFTGOAL)
				(fs ((as tgt (SoftGoal)) c))
				(fs ((as tgt (Resource)) c))
			)
		)
	)
)))
(assert (forall ((c DependerLink)) (= (ps c)
	(ite (= (tgtType c) TASK)
		(ps ((as tgt (Task)) c))
		(ite (= (tgtType c) GOAL)
			(ps ((as tgt (Goal)) c))
			(ite (= (tgtType c) SOFTGOAL)
				(ps ((as tgt (SoftGoal)) c))
				(ps ((as tgt (Resource)) c))
			)
		)
	)
)))
(assert (forall ((c DependerLink)) (= (un c)
	(ite (= (tgtType c) TASK)
		(un ((as tgt (Task)) c))
		(ite (= (tgtType c) GOAL)
			(un ((as tgt (Goal)) c))
			(ite (= (tgtType c) SOFTGOAL)
				(un ((as tgt (SoftGoal)) c))
				(un ((as tgt (Resource)) c))
			)
		)
	)
)))
(assert (forall ((c DependerLink)) (= (co c)
	(ite (= (tgtType c) TASK)
		(co ((as tgt (Task)) c))
		(ite (= (tgtType c) GOAL)
			(co ((as tgt (Goal)) c))
			(ite (= (tgtType c) SOFTGOAL)
				(co ((as tgt (SoftGoal)) c))
				(co ((as tgt (Resource)) c))
			)
		)
	)
)))
(assert (forall ((c DependerLink)) (= (pd c)
	(ite (= (tgtType c) TASK)
		(pd ((as tgt (Task)) c))
		(ite (= (tgtType c) GOAL)
			(pd ((as tgt (Goal)) c))
			(ite (= (tgtType c) SOFTGOAL)
				(pd ((as tgt (SoftGoal)) c))
				(pd ((as tgt (Resource)) c))
			)
		)
	)
)))
(assert (forall ((c DependerLink)) (= (fd c)
	(ite (= (tgtType c) TASK)
		(fd ((as tgt (Task)) c))
		(ite (= (tgtType c) GOAL)
			(fd ((as tgt (Goal)) c))
			(ite (= (tgtType c) SOFTGOAL)
				(fd ((as tgt (SoftGoal)) c))
				(fd ((as tgt (Resource)) c))
			)
		)
	)
)))
(assert (forall ((c DependeeLink)) (= (fs c)
	(ite (= (tgtType c) TASK)
		(fs ((as tgt (Task)) c))
		(ite (= (tgtType c) GOAL)
			(fs ((as tgt (Goal)) c))
			(ite (= (tgtType c) SOFTGOAL)
				(fs ((as tgt (SoftGoal)) c))
				(fs ((as tgt (Resource)) c))
			)
		)
	)
)))
(assert (forall ((c DependeeLink)) (= (ps c)
	(ite (= (tgtType c) TASK)
		(ps ((as tgt (Task)) c))
		(ite (= (tgtType c) GOAL)
			(ps ((as tgt (Goal)) c))
			(ite (= (tgtType c) SOFTGOAL)
				(ps ((as tgt (SoftGoal)) c))
				(ps ((as tgt (Resource)) c))
			)
		)
	)
)))
(assert (forall ((c DependeeLink)) (= (un c)
	(ite (= (tgtType c) TASK)
		(un ((as tgt (Task)) c))
		(ite (= (tgtType c) GOAL)
			(un ((as tgt (Goal)) c))
			(ite (= (tgtType c) SOFTGOAL)
				(un ((as tgt (SoftGoal)) c))
				(un ((as tgt (Resource)) c))
			)
		)
	)
)))
(assert (forall ((c DependeeLink)) (= (co c)
	(ite (= (tgtType c) TASK)
		(co ((as tgt (Task)) c))
		(ite (= (tgtType c) GOAL)
			(co ((as tgt (Goal)) c))
			(ite (= (tgtType c) SOFTGOAL)
				(co ((as tgt (SoftGoal)) c))
				(co ((as tgt (Resource)) c))
			)
		)
	)
)))
(assert (forall ((c DependeeLink)) (= (pd c)
	(ite (= (tgtType c) TASK)
		(pd ((as tgt (Task)) c))
		(ite (= (tgtType c) GOAL)
			(pd ((as tgt (Goal)) c))
			(ite (= (tgtType c) SOFTGOAL)
				(pd ((as tgt (SoftGoal)) c))
				(pd ((as tgt (Resource)) c))
			)
		)
	)
)))
(assert (forall ((c DependeeLink)) (= (fd c)
	(ite (= (tgtType c) TASK)
		(fd ((as tgt (Task)) c))
		(ite (= (tgtType c) GOAL)
			(fd ((as tgt (Goal)) c))
			(ite (= (tgtType c) SOFTGOAL)
				(fd ((as tgt (SoftGoal)) c))
				(fd ((as tgt (Resource)) c))
			)
		)
	)
)))

;Uninitialized labels
(declare-fun n (Task) Bool)
(declare-fun n (Goal) Bool)
(declare-fun n (SoftGoal) Bool)
(declare-fun n (Resource) Bool)
(declare-fun n (MeansEnd) Bool)
(declare-fun n (Decomposition) Bool)
(declare-fun n (Contribution) Bool)
(declare-fun n (DependerLink) Bool)
(declare-fun n (DependeeLink) Bool)
(assert (forall ((c MeansEnd)) (= (n c) (n (src c)))))
(assert (forall ((c Decomposition)) (= (n c)
	(ite (= (srcType c) TASK)
		(n ((as src (Task)) c))
		(ite (= (srcType c) GOAL)
			(n ((as src (Goal)) c))
			(ite (= (srcType c) SOFTGOAL)
				(n ((as src (SoftGoal)) c))
				(n ((as src (Resource)) c))
			)
		)
	)
)))
(assert (forall ((c Contribution)) (= (n c)
	(ite (= (srcType c) TASK)
		(n ((as src (Task)) c))
		(ite (= (srcType c) GOAL)
			(n ((as src (Goal)) c))
			(ite (= (srcType c) SOFTGOAL)
				(n ((as src (SoftGoal)) c))
				(n ((as src (Resource)) c))
			)
		)
	)
)))
(assert (forall ((c DependerLink)) (= (n c)
	(ite (= (tgtType c) TASK)
		(n ((as tgt (Task)) c))
		(ite (= (tgtType c) GOAL)
			(n ((as tgt (Goal)) c))
			(ite (= (tgtType c) SOFTGOAL)
				(n ((as tgt (SoftGoal)) c))
				(n ((as tgt (Resource)) c))
			)
		)
	)
)))
(assert (forall ((c DependeeLink)) (= (n c)
	(ite (= (tgtType c) TASK)
		(n ((as tgt (Task)) c))
		(ite (= (tgtType c) GOAL)
			(n ((as tgt (Goal)) c))
			(ite (= (tgtType c) SOFTGOAL)
				(n ((as tgt (SoftGoal)) c))
				(n ((as tgt (Resource)) c))
			)
		)
	)
)))

;Only one analysis label
(assert (forall ((c Task)) (xor (fs c) (ps c) (un c) (co c) (pd c) (fd c) (n c))))
(assert (forall ((c Goal)) (xor (fs c) (ps c) (un c) (co c) (pd c) (fd c) (n c))))
(assert (forall ((c SoftGoal)) (xor (fs c) (ps c) (un c) (co c) (pd c) (fd c) (n c))))
(assert (forall ((c Resource)) (xor (fs c) (ps c) (un c) (co c) (pd c) (fd c) (n c))))
[/template]

[template private encodeConstraints(istar : IStar)]

;No self-loops:
;;MeansEnd can't
;;Decomposition only from Task to Task
;;Contribution only from SoftGoal to SoftGoal
;;Depender and Dependee only if there are dependencies among dependums
(assert (forall ((c Decomposition)) (=>
	(= (srcType c) TASK)
	(not (= ((as src (Task)) c) (tgt c)))
)))
(assert (forall ((c Contribution)) (=>
	(= (srcType c) SOFTGOAL)
	(not (= ((as src (SoftGoal)) c) (tgt c)))
)))

;Complete Model
(assert	(forall ((c Actor)) (or
[for (actor : Actor | istar.actors)]
	(node [nodeName(actor)/] c)
[/for]
)))
[encodeOWIntentionConstraint(istar, 'Task')/]
[encodeOWIntentionConstraint(istar, 'Goal')/]
[encodeOWIntentionConstraint(istar, 'SoftGoal')/]
[encodeOWIntentionConstraint(istar, 'Resource')/]
(assert (forall ((c Containment)) (or
[for (actor : Actor | istar.actors)]
	[for (intention : Intention | actor.intentions)]
	(edge [edgeName(intention)/] c)
	[/for]
[/for]
)))
[encodeOWIntentionLinkConstraint(istar, 'MeansEnd')/]
[encodeOWIntentionLinkConstraint(istar, 'Decomposition')/]
[encodeOWIntentionLinkConstraint(istar, 'Contribution')/]
(assert (forall ((c DependerLink)) (or
[for (dependerLink : DependerLink | getAllDependerLinks(istar)->select(not depender.oclIsTypeOf(Actor)))]
	(edge [edgeName(dependerLink)/] c)
[/for]
)))
(assert (forall ((c DependeeLink)) (or
[for (dependeeLink : DependeeLink | getAllDependeeLinks(istar)->select(not dependee.oclIsTypeOf(Actor)))]
	(edge [edgeName(dependeeLink)/] c)
[/for]
)))

;Model Elements
[for (actor : Actor | istar.actors)]
	[if (not actor.may)]
[encodeMConstraint('Actor', 'node', nodeName(actor))/]
	[/if]
	[if (not actor.set)]
[encodeSConstraint('Actor', 'node', nodeName(actor))/]
	[/if]
	[let unmergeableActors : Sequence(String) = getUnmergeableModelObjects(istar, actor)]
	[if (not unmergeableActors->isEmpty())]
[encodeVConstraintPreamble(actor.eClass().name, 'node', nodeName(actor))/]
		[for (unmergeableActor : String | unmergeableActors)]
[encodeVConstraintBody('node', unmergeableActor)/]
		[/for]
[encodeVConstraintPostamble()/]
	[/if]
	[/let]
[/for]
[for (intention : Intention | getAllIntentions(istar))]
[encodeInitialAnalysis(intention)/]
[encodeMAVIntentionConstraints(istar, intention)/]
[/for]
[for (actor : Actor | istar.actors)]
	[for (intention : Intention | actor.intentions)]
		[let tgtClass : String = intention.eClass().name]
[encodeModelConstant('Containment', 'edge', edgeName(intention), 'tgtType', tgtClass.toUpper())/]
[encodeEdgeConstraint('Containment', edgeName(intention), '', nodeName(intention.eContainer(Actor)), tgtClass, nodeName(intention))/]
		[if (not intention.may)]
[encodeMConstraint('Containment', 'edge', edgeName(intention))/]
		[/if]
		[if (not intention.set)]
[encodeSConstraint('Containment', 'edge', edgeName(intention))/]
		[/if]
		[for (actor2 : Actor | istar.actors)]
			[if (not (actor.name = actor2.name))]
				[for (intention2 : Intention | actor2.intentions->select(eClass().name = tgtClass))]
					[if ((not actor.var and not actor2.var) or (not intention.var and not intention2.var))]
[encodeVConstraint('Containment', 'edge', edgeName(intention), edgeName(intention2))/]
					[/if]
				[/for]
			[/if]
		[/for]
		[if (not intention.var)]
			[for (intention2 : Intention | actor.intentions->select(eClass().name = tgtClass))]
				[if (not intention2.var and not (edgeName(intention) = edgeName(intention2)))]
[encodeVConstraint('Containment', 'edge', edgeName(intention), edgeName(intention2))/]
				[/if]
			[/for]
		[/if]
		[/let]
	[/for]
[/for]
[for (intentionLink : IntentionLink | getAllIntentionLinks(istar))]
[encodeMAVIntentionLinkConstraint(istar, intentionLink)/]
	[if (intentionLink.oclIsTypeOf(MeansEnd))]
[encodeIntentionLinkConstraint(intentionLink, false, false)/]
	[elseif (intentionLink.oclIsTypeOf(Decomposition))]
[encodeIntentionLinkConstraint(intentionLink, true, false)/]
	[elseif (intentionLink.oclIsTypeOf(Contribution))]
[encodeIntentionLinkConstraint(intentionLink, true, false)/]
[encodeIntentionLinkConstant(intentionLink, 'type', intentionLink.oclAsType(Contribution).type.toString())/]
	[/if]
[/for]
[for (dependerLink : DependerLink | getAllDependerLinks(istar)->select(not depender.oclIsTypeOf(Actor)))]
	[let srcClass : String = dependerLink.depender.eClass().name]
	[let tgtClass : String = dependerLink.dependum.eClass().name]
[encodeModelConstant('DependerLink', 'edge', edgeName(dependerLink), 'srcType', srcClass.toUpper())/]
[encodeModelConstant('DependerLink', 'edge', edgeName(dependerLink), 'tgtType', tgtClass.toUpper())/]
[encodeEdgeConstraint('DependerLink', edgeName(dependerLink), srcClass, nodeName(dependerLink.depender), tgtClass, nodeName(dependerLink.dependum))/]
	[if (not dependerLink.may)]
[encodeMDependerLinkConstraint(dependerLink)/]
	[/if]
	[if (not dependerLink.set)]
[encodeSDependerLinkConstraint(dependerLink)/]
	[/if]
	[let unmergeableDependerLinks : Sequence(String) = getUnmergeableModelObjects(istar, dependerLink)->reject(actorDepender : String | getAllDependerLinks(istar)->select(depender.oclIsTypeOf(Actor))->collect(edgeName())->includes(actorDepender))]
	[if (not unmergeableDependerLinks->isEmpty())]
[encodeVConstraintPreamble(dependerLink.eClass().name, 'edge', edgeName(dependerLink))/]
		[for (unmergeableDependerLink : String | unmergeableDependerLinks)]
[encodeVConstraintBody('edge', unmergeableDependerLink)/]
		[/for]
[encodeVConstraintPostamble()/]
	[/if]
	[/let]
	[/let]
	[/let]
[/for]
[for (dependeeLink : DependeeLink | getAllDependeeLinks(istar)->select(not dependee.oclIsTypeOf(Actor)))]
	[let srcClass : String = dependeeLink.dependum.eClass().name]
	[let tgtClass : String = dependeeLink.dependee.eClass().name]
[encodeModelConstant('DependeeLink', 'edge', edgeName(dependeeLink), 'srcType', srcClass.toUpper())/]
[encodeModelConstant('DependeeLink', 'edge', edgeName(dependeeLink), 'tgtType', tgtClass.toUpper())/]
[encodeEdgeConstraint('DependeeLink', edgeName(dependeeLink), srcClass, nodeName(dependeeLink.dependum), tgtClass, nodeName(dependeeLink.dependee))/]
	[if (not dependeeLink.may)]
[encodeMDependeeLinkConstraint(dependeeLink)/]
	[/if]
	[if (not dependeeLink.set)]
[encodeSDependeeLinkConstraint(dependeeLink)/]
	[/if]
	[let unmergeableDependeeLinks : Sequence(String) = getUnmergeableModelObjects(istar, dependeeLink)->reject(actorDependee : String | getAllDependeeLinks(istar)->select(dependee.oclIsTypeOf(Actor))->collect(edgeName())->includes(actorDependee))]
	[if (not unmergeableDependeeLinks->isEmpty())]
[encodeVConstraintPreamble(dependeeLink.eClass().name, 'edge', edgeName(dependeeLink))/]
		[for (unmergeableDependeeLink : String | unmergeableDependeeLinks)]
[encodeVConstraintBody('edge', unmergeableDependeeLink)/]
		[/for]
[encodeVConstraintPostamble()/]
	[/if]
	[/let]
	[/let]
	[/let]
[/for]
[/template]

[template private encodePropagation(istar : IStar)]

;Goal propagation (MeansEnd + Depender + Dependee)
(assert	(forall ((c Goal)) (=> (not (inited c)) (= (fs c) (ite
	(or
		(and (exists ((mec MeansEnd)) (and (= (tgt mec) c) (fs mec))) (not (exists ((dc DependerLink)) (and (= (srcType dc) GOAL) (= ((as src (Goal)) dc) c) (or (fd dc) (pd dc) (co dc) (un dc) (n dc) (ps dc))))))
		(and (exists ((dc1 DependerLink)) (and (= (srcType dc1) GOAL) (= ((as src (Goal)) dc1) c) (fs dc1))) (not (exists ((dc2 DependerLink)) (and (= (srcType dc2) GOAL) (= ((as src (Goal)) dc2) c) (or (fd dc2) (pd dc2) (co dc2) (un dc2) (n dc2) (ps dc2))))))
		(and (exists ((dc1 DependeeLink)) (and (= (srcType dc1) GOAL) (= ((as src (Goal)) dc1) c) (fs dc1))) (not (exists ((dc2 DependeeLink)) (and (= (srcType dc2) GOAL) (= ((as src (Goal)) dc2) c) (or (fd dc2) (pd dc2) (co dc2) (un dc2) (n dc2) (ps dc2))))))
	)
	true
	false
)))))
(assert	(forall ((c Goal)) (=> (and (not (inited c)) (fs c)) (= (ps c) false))))
(assert	(forall ((c Goal)) (=> (and (not (inited c)) (not (fs c))) (= (ps c) (ite
	(or
		(and (exists ((mec1 MeansEnd)) (and (= (tgt mec1) c) (ps mec1))) (and (not (exists ((mec2 MeansEnd)) (and (= (tgt mec2) c) (fs mec2)))) (not (exists ((dc DependerLink)) (and (= (srcType dc) GOAL) (= ((as src (Goal)) dc) c) (or (fd dc) (pd dc) (co dc) (un dc) (n dc)))))))
		(and (exists ((dc1 DependerLink)) (and (= (srcType dc1) GOAL) (= ((as src (Goal)) dc1) c) (ps dc1))) (not (exists ((dc2 DependerLink)) (and (= (srcType dc2) GOAL) (= ((as src (Goal)) dc2) c) (or (fd dc2) (pd dc2) (co dc2) (un dc2) (n dc2))))))
		(and (exists ((dc1 DependeeLink)) (and (= (srcType dc1) GOAL) (= ((as src (Goal)) dc1) c) (ps dc1))) (not (exists ((dc2 DependeeLink)) (and (= (srcType dc2) GOAL) (= ((as src (Goal)) dc2) c) (or (fd dc2) (pd dc2) (co dc2) (un dc2) (n dc2))))))
	)
	true
	false
)))))
(assert	(forall ((c Goal)) (=> (and (not (inited c)) (or (fs c) (ps c))) (= (n c) false))))
(assert	(forall ((c Goal)) (=> (and (not (inited c)) (not (fs c)) (not (ps c))) (= (n c) (ite
	(or
		(and (not (exists ((mec MeansEnd)) (= (tgt mec) c))) (not (exists ((dc1 DependerLink)) (and (= (srcType dc1) GOAL) (= ((as src (Goal)) dc1) c)))) (not (exists ((dc2 DependeeLink)) (and (= (srcType dc2) GOAL) (= ((as src (Goal)) dc2) c)))))
		(and (exists ((mec1 MeansEnd)) (and (= (tgt mec1) c) (n mec1))) (and (not (exists ((mec2 MeansEnd)) (and (= (tgt mec2) c) (or (fs mec2) (ps mec2) (un mec2) (co mec2) (pd mec2) (fd mec2))))) (not (exists ((dc DependerLink)) (and (= (srcType dc) GOAL) (= ((as src (Goal)) dc) c) (or (fd dc) (pd dc) (co dc) (un dc)))))))
		(and (exists ((dc1 DependerLink)) (and (= (srcType dc1) GOAL) (= ((as src (Goal)) dc1) c) (n dc1))) (not (exists ((dc2 DependerLink)) (and (= (srcType dc2) GOAL) (= ((as src (Goal)) dc2) c) (or (fd dc2) (pd dc2) (co dc2) (un dc2))))))
		(and (exists ((dc1 DependeeLink)) (and (= (srcType dc1) GOAL) (= ((as src (Goal)) dc1) c) (n dc1))) (not (exists ((dc2 DependeeLink)) (and (= (srcType dc2) GOAL) (= ((as src (Goal)) dc2) c) (or (fd dc2) (pd dc2) (co dc2) (un dc2))))))
	)
	true
	false
)))))
(assert	(forall ((c Goal)) (=> (and (not (inited c)) (or (fs c) (ps c) (n c))) (= (un c) false))))
(assert	(forall ((c Goal)) (=> (and (not (inited c)) (not (fs c)) (not (ps c)) (not (n c))) (= (un c) (ite
	(or
		(and (exists ((mec1 MeansEnd)) (and (= (tgt mec1) c) (un mec1))) (and (not (exists ((mec2 MeansEnd)) (and (= (tgt mec2) c) (or (fs mec2) (ps mec2))))) (not (exists ((dc DependerLink)) (and (= (srcType dc) GOAL) (= ((as src (Goal)) dc) c) (or (fd dc) (pd dc) (co dc)))))))
		(and (exists ((dc1 DependerLink)) (and (= (srcType dc1) GOAL) (= ((as src (Goal)) dc1) c) (un dc1))) (not (exists ((dc2 DependerLink)) (and (= (srcType dc2) GOAL) (= ((as src (Goal)) dc2) c) (or (fd dc2) (pd dc2) (co dc2))))))
		(and (exists ((dc1 DependeeLink)) (and (= (srcType dc1) GOAL) (= ((as src (Goal)) dc1) c) (un dc1))) (not (exists ((dc2 DependeeLink)) (and (= (srcType dc2) GOAL) (= ((as src (Goal)) dc2) c) (or (fd dc2) (pd dc2) (co dc2))))))
	)
	true
	false
)))))
(assert	(forall ((c Goal)) (=> (and (not (inited c)) (or (fs c) (ps c) (n c) (un c))) (= (co c) false))))
(assert	(forall ((c Goal)) (=> (and (not (inited c)) (not (fs c)) (not (ps c)) (not (n c)) (not (un c))) (= (co c) (ite
	(or
		(and (exists ((mec1 MeansEnd)) (and (= (tgt mec1) c) (co mec1))) (and (not (exists ((mec2 MeansEnd)) (and (= (tgt mec2) c) (or (fs mec2) (ps mec2) (un mec2))))) (not (exists ((dc DependerLink)) (and (= (srcType dc) GOAL) (= ((as src (Goal)) dc) c) (or (fd dc) (pd dc)))))))
		(and (exists ((dc1 DependerLink)) (and (= (srcType dc1) GOAL) (= ((as src (Goal)) dc1) c) (co dc1))) (not (exists ((dc2 DependerLink)) (and (= (srcType dc2) GOAL) (= ((as src (Goal)) dc2) c) (or (fd dc2) (pd dc2))))))
		(and (exists ((dc1 DependeeLink)) (and (= (srcType dc1) GOAL) (= ((as src (Goal)) dc1) c) (co dc1))) (not (exists ((dc2 DependeeLink)) (and (= (srcType dc2) GOAL) (= ((as src (Goal)) dc2) c) (or (fd dc2) (pd dc2))))))
	)
	true
	false
)))))
(assert	(forall ((c Goal)) (=> (and (not (inited c)) (or (fs c) (ps c) (n c) (un c) (co c))) (= (pd c) false))))
(assert	(forall ((c Goal)) (=> (and (not (inited c)) (not (fs c)) (not (ps c)) (not (n c)) (not (un c)) (not (co c))) (= (pd c) (ite
	(or
		(and (exists ((mec1 MeansEnd)) (and (= (tgt mec1) c) (pd mec1))) (and (not (exists ((mec2 MeansEnd)) (and (= (tgt mec2) c) (or (fs mec2) (ps mec2) (un mec2) (co mec2))))) (not (exists ((dc DependerLink)) (and (= (srcType dc) GOAL) (= ((as src (Goal)) dc) c) (fd dc))))))
		(and (exists ((dc1 DependerLink)) (and (= (srcType dc1) GOAL) (= ((as src (Goal)) dc1) c) (pd dc1))) (not (exists ((dc2 DependerLink)) (and (= (srcType dc2) GOAL) (= ((as src (Goal)) dc2) c) (fd dc2)))))
		(and (exists ((dc1 DependeeLink)) (and (= (srcType dc1) GOAL) (= ((as src (Goal)) dc1) c) (pd dc1))) (not (exists ((dc2 DependeeLink)) (and (= (srcType dc2) GOAL) (= ((as src (Goal)) dc2) c) (fd dc2)))))
	)
	true
	false
)))))
(assert	(forall ((c Goal)) (=> (and (not (inited c)) (or (fs c) (ps c) (n c) (un c) (co c) (pd c))) (= (fd c) false))))
(assert	(forall ((c Goal)) (=> (and (not (inited c)) (not (fs c)) (not (ps c)) (not (n c)) (not (un c)) (not (co c)) (not (pd c))) (= (fd c) true))))
;(assert	(forall ((c Goal)) (=> (not (inited c)) (= (fd c) (ite
;	(or
;		(and (exists ((mec1 MeansEnd)) (and (= (tgt mec1) c) (fd mec1))) (not (exists ((mec2 MeansEnd)) (and (= (tgt mec2) c) (or (fs mec2) (ps mec2) (un mec2) (co mec2) (pd mec2))))))
;		(exists ((dc DependerLink)) (and (= (srcType dc) GOAL) (= ((as src (Goal)) dc) c) (fd dc)))
;		(exists ((dc DependeeLink)) (and (= (srcType dc) GOAL) (= ((as src (Goal)) dc) c) (fd dc)))
;	)
;	true
;	false
;)))))

;Task propagation (Decomposition + Depender)
(assert (forall ((c Task)) (=> (not (inited c)) (= (fd c) (ite
	(or
		(exists ((dc Decomposition)) (and (= (tgt dc) c) (fd dc)))
		(exists ((dc DependerLink)) (and (= (srcType dc) TASK) (= ((as src (Task)) dc) c) (fd dc)))
	)
	true
	false
)))))
(assert (forall ((c Task)) (=> (and (not (inited c)) (fd c))  (= (pd c) false))))
(assert (forall ((c Task)) (=> (and (not (inited c)) (not (fd c)))  (= (pd c) (ite
	(or
		(and (exists ((dc1 Decomposition)) (and (= (tgt dc1) c) (pd dc1))) (not (exists ((dc2 Decomposition)) (and (= (tgt dc2) c) (fd dc2)))) (not (exists ((dc3 DependerLink)) (and (= (srcType dc3) TASK) (= ((as src (Task)) dc3) c) (fd dc3)))))
		(and (exists ((dc1 DependerLink)) (and (= (srcType dc1) TASK) (= ((as src (Task)) dc1) c) (pd dc1))) (not (exists ((dc2 DependerLink)) (and (= (srcType dc2) TASK) (= ((as src (Task)) dc2) c) (fd dc2)))) (not (exists ((dc3 Decomposition)) (and (= (tgt dc3) c) (fd dc3)))))
	)
	true
	false
)))))
(assert (forall ((c Task)) (=> (and (not (inited c)) (or (fd c) (pd c)))  (= (co c) false))))
(assert (forall ((c Task)) (=> (and (not (inited c)) (not (fd c)) (not (pd c)))  (= (co c) (ite
	(or
		(and (exists ((dc1 Decomposition)) (and (= (tgt dc1) c) (co dc1))) (not (exists ((dc2 Decomposition)) (and (= (tgt dc2) c) (or (fd dc2) (pd dc2))))) (not (exists ((dc3 DependerLink)) (and (= (srcType dc3) TASK) (= ((as src (Task)) dc3) c) (or (fd dc3) (pd dc3))))))
		(and (exists ((dc1 DependerLink)) (and (= (srcType dc1) TASK) (= ((as src (Task)) dc1) c) (co dc1))) (not (exists ((dc2 DependerLink)) (and (= (srcType dc2) TASK) (= ((as src (Task)) dc2) c) (or (fd dc2) (pd dc2))))) (not (exists ((dc3 Decomposition)) (and (= (tgt dc3) c) (or (fd dc3) (pd dc3))))))
	)
	true
	false
)))))
(assert (forall ((c Task)) (=> (and (not (inited c)) (or (fd c) (pd c) (co c)))  (= (un c) false))))
(assert (forall ((c Task)) (=> (and (not (inited c)) (not (fd c)) (not (pd c)) (not (co c)))  (= (un c) (ite
	(or
		(and (exists ((dc1 Decomposition)) (and (= (tgt dc1) c) (un dc1))) (not (exists ((dc2 Decomposition)) (and (= (tgt dc2) c) (or (fd dc2) (pd dc2) (co dc2))))) (not (exists ((dc3 DependerLink)) (and (= (srcType dc3) TASK) (= ((as src (Task)) dc3) c) (or (fd dc3) (pd dc3) (co dc3))))))
		(and (exists ((dc1 DependerLink)) (and (= (srcType dc1) TASK) (= ((as src (Task)) dc1) c) (un dc1))) (not (exists ((dc2 DependerLink)) (and (= (srcType dc2) TASK) (= ((as src (Task)) dc2) c) (or (fd dc2) (pd dc2) (co dc2))))) (not (exists ((dc3 Decomposition)) (and (= (tgt dc3) c) (or (fd dc3) (pd dc3) (co dc3))))))
	)
	true
	false
)))))
(assert (forall ((c Task)) (=> (and (not (inited c)) (or (fd c) (pd c) (co c) (un c)))  (= (n c) false))))
(assert (forall ((c Task)) (=> (and (not (inited c)) (not (fd c)) (not (pd c)) (not (co c)) (not (un c)))  (= (n c) (ite
	(or
		(and (not (exists ((dc1 Decomposition)) (= (tgt dc1) c))) (not (exists ((dc2 DependerLink)) (and (= (srcType dc2) TASK) (= ((as src (Task)) dc2) c)))))
		(and (exists ((dc1 Decomposition)) (and (= (tgt dc1) c) (n dc1))) (not (exists ((dc2 Decomposition)) (and (= (tgt dc2) c) (or (fd dc2) (pd dc2) (co dc2) (un dc2))))) (not (exists ((dc3 DependerLink)) (and (= (srcType dc3) TASK) (= ((as src (Task)) dc3) c) (or (fd dc3) (pd dc3) (co dc3) (un dc3))))))
		(and (exists ((dc1 DependerLink)) (and (= (srcType dc1) TASK) (= ((as src (Task)) dc1) c) (n dc1))) (not (exists ((dc2 DependerLink)) (and (= (srcType dc2) TASK) (= ((as src (Task)) dc2) c) (or (fd dc2) (pd dc2) (co dc2) (un dc2))))) (not (exists ((dc3 Decomposition)) (and (= (tgt dc3) c) (or (fd dc3) (pd dc3) (co dc3) (un dc3))))))
	)
	true
	false
)))))
(assert (forall ((c Task)) (=> (and (not (inited c)) (or (fd c) (pd c) (co c) (un c) (n c)))  (= (ps c) false))))
(assert (forall ((c Task)) (=> (and (not (inited c)) (not (fd c)) (not (pd c)) (not (co c)) (not (un c)) (not (n c)))  (= (ps c) (ite
	(or
		(and (exists ((dc1 Decomposition)) (and (= (tgt dc1) c) (ps dc1))) (not (exists ((dc2 Decomposition)) (and (= (tgt dc2) c) (or (fd dc2) (pd dc2) (co dc2) (un dc2) (n dc2))))) (not (exists ((dc3 DependerLink)) (and (= (srcType dc3) TASK) (= ((as src (Task)) dc3) c) (or (fd dc3) (pd dc3) (co dc3) (un dc3) (n dc3))))))
		(and (exists ((dc1 DependerLink)) (and (= (srcType dc1) TASK) (= ((as src (Task)) dc1) c) (ps dc1))) (not (exists ((dc2 DependerLink)) (and (= (srcType dc2) TASK) (= ((as src (Task)) dc2) c) (or (fd dc2) (pd dc2) (co dc2) (un dc2) (n dc2))))) (not (exists ((dc3 Decomposition)) (and (= (tgt dc3) c) (or (fd dc3) (pd dc3) (co dc3) (un dc3) (n dc3))))))
	)
	true
	false
)))))
(assert (forall ((c Task)) (=> (and (not (inited c)) (or (fd c) (pd c) (co c) (un c) (n c) (ps c)))  (= (fs c) false))))
(assert (forall ((c Task)) (=> (and (not (inited c)) (not (fd c)) (not (pd c)) (not (co c)) (not (un c)) (not (n c)) (not (ps c)))  (= (fs c) true))))
;(assert (forall ((c Task)) (=> (not (inited c))  (= (fs c) (ite
;	(or
;		(and (exists ((dc1 Decomposition)) (and (= (tgt dc1) c) (fs dc1))) (not (exists ((dc2 Decomposition)) (and (= (tgt dc2) c) (or (fd dc2) (pd dc2) (co dc2) (un dc2) (n dc2) (ps dc2))))) (not (exists ((dc3 DependerLink)) (and (= (srcType dc3) TASK) (= ((as src (Task)) dc3) c) (or (fd dc3) (pd dc3) (co dc3) (un dc3) (n dc3) (ps dc3))))))
;		(and (exists ((dc1 DependerLink)) (and (= (srcType dc1) TASK) (= ((as src (Task)) dc1) c) (fs dc1))) (not (exists ((dc2 DependerLink)) (and (= (srcType dc2) TASK) (= ((as src (Task)) dc2) c) (or (fd dc2) (pd dc2) (co dc2) (un dc2) (n dc2) (ps dc2))))) (not (exists ((dc3 Decomposition)) (and (= (tgt dc3) c) (or (fd dc3) (pd dc3) (co dc3) (un dc3) (n dc3) (ps dc3))))))
;	)
;	true
;	false
;)))))

;SoftGoal propagation (Contribution + Depender + Dependee)
(assert (forall ((c SoftGoal)) (=> (not (inited c)) (= (co c) (ite
	(or
		(and
			(or
				(exists ((cc1 Contribution)) (and (= (tgt cc1) c) (co cc1)))
				(exists ((cc2 Contribution) (cc3 Contribution)) (and (= (tgt cc2) c) (= (tgt cc3) c) (or (fs cc2) (ps cc2)) (or (pd cc3) (fd cc3))))
			)
			(not (exists ((dc DependerLink)) (and (= (srcType dc) SOFTGOAL) (= ((as src (SoftGoal)) dc) c) (or (fd dc) (pd dc)))))
		)
		(and
			(exists ((dc1 DependerLink)) (and (= (srcType dc1) SOFTGOAL) (= ((as src (SoftGoal)) dc1) c) (co dc1)))
			(not (exists ((dc2 DependerLink)) (and (= (srcType dc2) SOFTGOAL) (= ((as src (SoftGoal)) dc2) c) (or (fd dc2) (pd dc2)))))
			;not exists fd|pd
			(not (and
				(exists ((cc1 Contribution)) (and (= (tgt cc1) c) (or (fd cc1) (pd cc1))))
				(not (exists ((cc2 Contribution)) (and (= (tgt cc2) c) (or (co cc2) (un cc2) (fs cc2) (ps cc2)))))
			))
		)
		(and
			(exists ((dc1 DependeeLink)) (and (= (srcType dc1) SOFTGOAL) (= ((as src (SoftGoal)) dc1) c) (co dc1)))
			(not (exists ((dc2 DependeeLink)) (and (= (srcType dc2) SOFTGOAL) (= ((as src (SoftGoal)) dc2) c) (or (fd dc2) (pd dc2)))))
		)
	)
	true
	false
)))))
(assert (forall ((c SoftGoal)) (=> (and (not (inited c)) (co c)) (= (un c) false))))
(assert (forall ((c SoftGoal)) (=> (and (not (inited c)) (not (co c))) (= (un c) (ite
	(or
		(and
			(exists ((cc1 Contribution)) (and (= (tgt cc1) c) (un cc1)))
			(not (exists ((cc2 Contribution)) (and (= (tgt cc2) c) (co cc2))))
			(not (exists ((cc3 Contribution) (cc4 Contribution)) (and (= (tgt cc3) c) (= (tgt cc4) c) (or (fs cc3) (ps cc3)) (or (pd cc4) (fd cc4)))))
			(not (exists ((dc DependerLink)) (and (= (srcType dc) SOFTGOAL) (= ((as src (SoftGoal)) dc) c) (or (fd dc) (pd dc) (co dc)))))
		)
		(and
			(exists ((dc1 DependerLink)) (and (= (srcType dc1) SOFTGOAL) (= ((as src (SoftGoal)) dc1) c) (un dc1)))
			(not (exists ((dc2 DependerLink)) (and (= (srcType dc2) SOFTGOAL) (= ((as src (SoftGoal)) dc2) c) (or (fd dc2) (pd dc2) (co dc2)))))
			;not exists fd|pd|co_
			(not (and
				(exists ((cc1 Contribution)) (and (= (tgt cc1) c) (or (fd cc1) (pd cc1))))
				(not (exists ((cc2 Contribution)) (and (= (tgt cc2) c) (un cc2))))
			))
			;not exists co
			(not (exists ((cc3 Contribution)) (and (= (tgt cc3) c) (co cc3))))
		)
		(and
			(exists ((dc1 DependeeLink)) (and (= (srcType dc1) SOFTGOAL) (= ((as src (SoftGoal)) dc1) c) (un dc1)))
			(not (exists ((dc2 DependeeLink)) (and (= (srcType dc2) SOFTGOAL) (= ((as src (SoftGoal)) dc2) c) (or (fd dc2) (pd dc2) (co dc2)))))
		)
	)
	true
	false
)))))
(assert (forall ((c SoftGoal)) (=> (and (not (inited c)) (or (co c) (un c))) (= (fd c) false))))
(assert (forall ((c SoftGoal)) (=> (and (not (inited c)) (not (co c)) (not (un c))) (= (fd c) (ite
	(or
		(and
			(exists ((cc1 Contribution)) (and (= (tgt cc1) c) (fd cc1)))
			(not (exists ((cc2 Contribution)) (and (= (tgt cc2) c) (or (co cc2) (un cc2) (fs cc2) (ps cc2)))))
		)
		(exists ((dc DependerLink)) (and (= (srcType dc) SOFTGOAL) (= ((as src (SoftGoal)) dc) c) (fd dc)))
		(exists ((dc DependeeLink)) (and (= (srcType dc) SOFTGOAL) (= ((as src (SoftGoal)) dc) c) (fd dc)))
	)
	true
	false
)))))
(assert (forall ((c SoftGoal)) (=> (and (not (inited c)) (or (co c) (un c) (fd c))) (= (pd c) false))))
(assert (forall ((c SoftGoal)) (=> (and (not (inited c)) (not (co c)) (not (un c)) (not (fd c))) (= (pd c) (ite
	(or
		(and
			(exists ((cc1 Contribution)) (and (= (tgt cc1) c) (pd cc1)))
			(not (exists ((cc2 Contribution)) (and (= (tgt cc2) c) (or (co cc2) (un cc2) (fd cc2) (fs cc2) (ps cc2)))))
			(not (exists ((dc DependerLink)) (and (= (srcType dc) SOFTGOAL) (= ((as src (SoftGoal)) dc) c) (fd dc))))
		)
		(and
			(exists ((dc1 DependerLink)) (and (= (srcType dc1) SOFTGOAL) (= ((as src (SoftGoal)) dc1) c) (pd dc1)))
			(not (exists ((dc2 DependerLink)) (and (= (srcType dc2) SOFTGOAL) (= ((as src (SoftGoal)) dc2) c) (fd dc2))))
			;not exists fd
			(not (and
				(exists ((cc1 Contribution)) (and (= (tgt cc1) c) (fd cc1)))
				(not (exists ((cc2 Contribution)) (and (= (tgt cc2) c) (or (co cc2) (un cc2) (fs cc2) (ps cc2)))))
			))
		)
		(and
			(exists ((dc1 DependeeLink)) (and (= (srcType dc1) SOFTGOAL) (= ((as src (SoftGoal)) dc1) c) (pd dc1)))
			(not (exists ((dc2 DependeeLink)) (and (= (srcType dc2) SOFTGOAL) (= ((as src (SoftGoal)) dc2) c) (fd dc2))))
		)
	)
	true
	false
)))))
(assert (forall ((c SoftGoal)) (=> (and (not (inited c)) (or (co c) (un c) (fd c) (pd c))) (= (fs c) false))))
(assert (forall ((c SoftGoal)) (=> (and (not (inited c)) (not (co c)) (not (un c)) (not (fd c)) (not (pd c))) (= (fs c) (ite
	(or
		(and
			(exists ((cc1 Contribution)) (and (= (tgt cc1) c) (fs cc1)))
			(not (exists ((cc2 Contribution)) (and (= (tgt cc2) c) (or (co cc2) (un cc2) (fd cc2) (pd cc2)))))
			(not (exists ((dc DependerLink)) (and (= (srcType dc) SOFTGOAL) (= ((as src (SoftGoal)) dc) c) (or (fd dc) (pd dc) (co dc) (un dc) (n dc) (ps dc)))))
		)
		(and
			(exists ((dc1 DependerLink)) (and (= (srcType dc1) SOFTGOAL) (= ((as src (SoftGoal)) dc1) c) (fs dc1)))
			(not (exists ((dc2 DependerLink)) (and (= (srcType dc2) SOFTGOAL) (= ((as src (SoftGoal)) dc2) c) (or (fd dc2) (pd dc2) (co dc2) (un dc2) (n dc2) (ps dc2)))))
			;not exists fd|pd|co|co_|un
			(not (exists ((cc1 Contribution)) (and (= (tgt cc1) c) (or (co cc1) (un cc1) (fd cc1) (pd cc1)))))
			;not exists n
			(not (and
				(exists ((cc2 Contribution)) (and (= (tgt cc2) c) (n cc2)))
				(not (exists ((cc3 Contribution)) (and (= (tgt cc3) c) (or (co cc3) (un cc3) (fd cc3) (pd cc3) (fs cc3) (ps cc3)))))
			))
			;not exists ps
			(not (and
				(exists ((cc4 Contribution)) (and (= (tgt cc4) c) (ps cc4)))
				(not (exists ((cc5 Contribution)) (and (= (tgt cc5) c) (or (co cc5) (un cc5) (fd cc5) (pd cc5) (fs cc5)))))
			))
		)
		(and
			(exists ((dc1 DependeeLink)) (and (= (srcType dc1) SOFTGOAL) (= ((as src (SoftGoal)) dc1) c) (fs dc1)))
			(not (exists ((dc2 DependeeLink)) (and (= (srcType dc2) SOFTGOAL) (= ((as src (SoftGoal)) dc2) c) (or (fd dc2) (pd dc2) (co dc2) (un dc2) (n dc2) (ps dc2)))))
		)
	)
	true
	false
)))))
(assert (forall ((c SoftGoal)) (=> (and (not (inited c)) (or (co c) (un c) (fd c) (pd c) (fs c))) (= (ps c) false))))
(assert (forall ((c SoftGoal)) (=> (and (not (inited c)) (not (co c)) (not (un c)) (not (fd c)) (not (pd c)) (not (fs c))) (= (ps c) (ite
	(or
		(and
			(exists ((cc1 Contribution)) (and (= (tgt cc1) c) (ps cc1)))
			(not (exists ((cc2 Contribution)) (and (= (tgt cc2) c) (or (co cc2) (un cc2) (fd cc2) (pd cc2) (fs cc2)))))
			(not (exists ((dc DependerLink)) (and (= (srcType dc) SOFTGOAL) (= ((as src (SoftGoal)) dc) c) (or (fd dc) (pd dc) (co dc) (un dc) (n dc)))))
		)
		(and
			(exists ((dc1 DependerLink)) (and (= (srcType dc1) SOFTGOAL) (= ((as src (SoftGoal)) dc1) c) (ps dc1)))
			(not (exists ((dc2 DependerLink)) (and (= (srcType dc2) SOFTGOAL) (= ((as src (SoftGoal)) dc2) c) (or (fd dc2) (pd dc2) (co dc2) (un dc2) (n dc2)))))
			;not exists fd|pd|co|co_|un
			(not (exists ((cc1 Contribution)) (and (= (tgt cc1) c) (or (co cc1) (un cc1) (fd cc1) (pd cc1)))))
			;not exists n
			(not (and
				(exists ((cc2 Contribution)) (and (= (tgt cc2) c) (n cc2)))
				(not (exists ((cc3 Contribution)) (and (= (tgt cc3) c) (or (co cc3) (un cc3) (fd cc3) (pd cc3) (fs cc3) (ps cc3)))))
			))
		)
		(and
			(exists ((dc1 DependeeLink)) (and (= (srcType dc1) SOFTGOAL) (= ((as src (SoftGoal)) dc1) c) (ps dc1)))
			(not (exists ((dc2 DependeeLink)) (and (= (srcType dc2) SOFTGOAL) (= ((as src (SoftGoal)) dc2) c) (or (fd dc2) (pd dc2) (co dc2) (un dc2) (n dc2)))))
		)
	)
	true
	false
)))))
(assert (forall ((c SoftGoal)) (=> (and (not (inited c)) (or (co c) (un c) (fd c) (pd c) (fs c) (ps c))) (= (n c) false))))
(assert (forall ((c SoftGoal)) (=> (and (not (inited c)) (not (co c)) (not (un c)) (not (fd c)) (not (pd c)) (not (fs c)) (not (ps c))) (= (n c) true))))
;(assert (forall ((c SoftGoal)) (=> (and (not (inited c)) (not (co c)) (not (un c)) (not (fd c)) (not (pd c)) (not (fs c)) (not (ps c))) (= (n c) (ite
;	(or
;		(and
;			(not (exists ((cc Contribution)) (= (tgt cc) c)))
;			(not (exists ((dc1 DependerLink)) (and (= (srcType dc1) SOFTGOAL) (= ((as src (SoftGoal)) dc1) c))))
;			(not (exists ((dc2 DependeeLink)) (and (= (srcType dc2) SOFTGOAL) (= ((as src (SoftGoal)) dc2) c))))
;		)
;		(and
;			(exists ((cc1 Contribution)) (and (= (tgt cc1) c) (n cc1)))
;			(not (exists ((cc2 Contribution)) (and (= (tgt cc2) c) (or (co cc2) (un cc2) (fd cc2) (pd cc2) (fs cc2) (ps cc2)))))
;			(not (exists ((dc DependerLink)) (and (= (srcType dc) SOFTGOAL) (= ((as src (SoftGoal)) dc) c) (or (fd dc) (pd dc) (co dc) (un dc)))))
;		)
;		(and
;			(exists ((dc1 DependerLink)) (and (= (srcType dc1) SOFTGOAL) (= ((as src (SoftGoal)) dc1) c) (n dc1)))
;			(not (exists ((dc2 DependerLink)) (and (= (srcType dc2) SOFTGOAL) (= ((as src (SoftGoal)) dc2) c) (or (fd dc2) (pd dc2) (co dc2) (un dc2)))))
;			;not exists fd|pd|co|co_|un
;			(not (exists ((cc1 Contribution)) (and (= (tgt cc1) c) (or (co cc1) (un cc1) (fd cc1) (pd cc1)))))
;		)
;		(and
;			(exists ((dc1 DependeeLink)) (and (= (srcType dc1) SOFTGOAL) (= ((as src (SoftGoal)) dc1) c) (n dc1)))
;			(not (exists ((dc2 DependeeLink)) (and (= (srcType dc2) SOFTGOAL) (= ((as src (SoftGoal)) dc2) c) (or (fd dc2) (pd dc2) (co dc2) (un dc2)))))
;		)
;	)
;	true
;	false
;)))))

;Resource propagation (only Dependee)
(assert (forall ((c Resource)) (=> (not (inited c)) (= (fd c) (ite
	(exists ((dc DependeeLink)) (and (= (srcType dc) RESOURCE) (= ((as src (Resource)) dc) c) (fd dc)))
	true
	false
)))))
(assert (forall ((c Resource)) (=> (and (not (inited c)) (fd c))  (= (pd c) false))))
(assert (forall ((c Resource)) (=> (and (not (inited c)) (not (fd c)))  (= (pd c) (ite
	(and (exists ((dc1 DependeeLink)) (and (= (srcType dc1) RESOURCE) (= ((as src (Resource)) dc1) c) (pd dc1))) (not (exists ((dc2 DependeeLink)) (and (= (srcType dc2) RESOURCE) (= ((as src (Resource)) dc2) c) (fd dc2)))))
	true
	false
)))))
(assert (forall ((c Resource)) (=> (and (not (inited c)) (or (fd c) (pd c)))  (= (co c) false))))
(assert (forall ((c Resource)) (=> (and (not (inited c)) (not (fd c)) (not (pd c)))  (= (co c) (ite
	(and (exists ((dc1 DependeeLink)) (and (= (srcType dc1) RESOURCE) (= ((as src (Resource)) dc1) c) (co dc1))) (not (exists ((dc2 DependeeLink)) (and (= (srcType dc2) RESOURCE) (= ((as src (Resource)) dc2) c) (or (fd dc2) (pd dc2))))))
	true
	false
)))))
(assert (forall ((c Resource)) (=> (and (not (inited c)) (or (fd c) (pd c) (co c)))  (= (un c) false))))
(assert (forall ((c Resource)) (=> (and (not (inited c)) (not (fd c)) (not (pd c)) (not (co c)))  (= (un c) (ite
	(and (exists ((dc1 DependeeLink)) (and (= (srcType dc1) RESOURCE) (= ((as src (Resource)) dc1) c) (un dc1))) (not (exists ((dc2 DependeeLink)) (and (= (srcType dc2) RESOURCE) (= ((as src (Resource)) dc2) c) (or (fd dc2) (pd dc2) (co dc2))))))
	true
	false
)))))
(assert (forall ((c Resource)) (=> (and (not (inited c)) (or (fd c) (pd c) (co c) (un c)))  (= (n c) false))))
(assert (forall ((c Resource)) (=> (and (not (inited c)) (not (fd c)) (not (pd c)) (not (co c)) (not (un c)))  (= (n c) (ite
	(or
		(not (exists ((dc DependeeLink)) (and (= (srcType dc) RESOURCE) (= ((as src (Resource)) dc) c))))
		(and (exists ((dc1 DependeeLink)) (and (= (srcType dc1) RESOURCE) (= ((as src (Resource)) dc1) c) (n dc1))) (not (exists ((dc2 DependeeLink)) (and (= (srcType dc2) RESOURCE) (= ((as src (Resource)) dc2) c) (or (fd dc2) (pd dc2) (co dc2) (un dc2))))))
	)
	true
	false
)))))
(assert (forall ((c Resource)) (=> (and (not (inited c)) (or (fd c) (pd c) (co c) (un c) (n c)))  (= (ps c) false))))
(assert (forall ((c Resource)) (=> (and (not (inited c)) (not (fd c)) (not (pd c)) (not (co c)) (not (un c)) (not (n c)))  (= (ps c) (ite
	(and (exists ((dc1 DependeeLink)) (and (= (srcType dc1) RESOURCE) (= ((as src (Resource)) dc1) c) (ps dc1))) (not (exists ((dc2 DependeeLink)) (and (= (srcType dc2) RESOURCE) (= ((as src (Resource)) dc2) c) (or (fd dc2) (pd dc2) (co dc2) (un dc2) (n dc2))))))
	true
	false
)))))
(assert (forall ((c Resource)) (=> (and (not (inited c)) (or (fd c) (pd c) (co c) (un c) (n c) (ps c)))  (= (fs c) false))))
(assert (forall ((c Resource)) (=> (and (not (inited c)) (not (fd c)) (not (pd c)) (not (co c)) (not (un c)) (not (n c)) (not (ps c)))  (= (fs c) true))))
;(assert (forall ((c Resource)) (=> (not (inited c))  (= (fs c) (ite
;	(and (exists ((dc1 DependeeLink)) (and (= (srcType dc1) RESOURCE) (= ((as src (Resource)) dc1) c) (fs dc1))) (not (exists ((dc2 DependeeLink)) (and (= (srcType dc2) RESOURCE) (= ((as src (Resource)) dc2) c) (or (fd dc2) (pd dc2) (co dc2) (un dc2) (n dc2) (ps dc2))))))
;	true
;	false
;)))))
[/template]

[template public encodeIStarMAVO(istar : IStar, modelName : String)]
[comment @main/]
[file (modelName + '.smt2', false, 'UTF-8')]
[createFormulaIdsFromNames(istar)/]
[encodeConstants(istar)/]
[encodeModel(istar)/]
[encodeAnalysis(istar)/]
[encodeConstraints(istar)/]
[encodePropagation(istar)/]
[/file]
[/template]
